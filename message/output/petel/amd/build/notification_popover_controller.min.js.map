{"version":3,"file":"notification_popover_controller.min.js","sources":["../src/notification_popover_controller.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Controls the notification popover in the nav bar.\r\n *\r\n * See template: message_petel/notification_popover\r\n *\r\n * @module     message_petel/notification_popover_controller\r\n * @class      notification_popover_controller\r\n * @package    message_petel\r\n * @copyright  2016 Ryan Wyllie <ryan@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\ndefine(['jquery', 'core/ajax', 'core/templates', 'core/str', 'core/url',\r\n            'core/notification', 'core/custom_interaction_events', 'core/popover_region_controller',\r\n            'message_petel/notification_repository', 'message_petel/notification_area_events'],\r\n        function($, Ajax, Templates, Str, URL, DebugNotification, CustomEvents,\r\n            PopoverController, NotificationRepo, NotificationAreaEvents) {\r\n\r\n    var SELECTORS = {\r\n        MARK_ALL_READ_BUTTON: '[data-action=\"mark-all-read\"]',\r\n        ALL_NOTIFICATIONS_CONTAINER: '[data-region=\"all-notifications\"]',\r\n        NOTIFICATION: '[data-region=\"notification-content-item-container\"]',\r\n        UNREAD_NOTIFICATION: '[data-region=\"notification-content-item-container\"].unread',\r\n        NOTIFICATION_LINK: '[data-action=\"content-item-link\"]',\r\n        EMPTY_MESSAGE: '[data-region=\"empty-message\"]',\r\n        COUNT_CONTAINER: '[data-region=\"count-container\"]',\r\n    };\r\n\r\n    /**\r\n     * Constructor for the NotificationPopoverController.\r\n     * Extends PopoverRegionController.\r\n     *\r\n     * @param {object} element jQuery object root element of the popover\r\n     */\r\n    var NotificationPopoverController = function(element) {\r\n        // Initialise base class.\r\n        PopoverController.call(this, element);\r\n\r\n        this.markAllReadButton = this.root.find(SELECTORS.MARK_ALL_READ_BUTTON);\r\n        this.unreadCount = 0;\r\n        this.userId = this.root.attr('data-userid');\r\n        this.container = this.root.find(SELECTORS.ALL_NOTIFICATIONS_CONTAINER);\r\n        this.limit = 20;\r\n        this.offset = 0;\r\n        this.loadedAll = false;\r\n        this.initialLoad = false;\r\n\r\n        // Let's find out how many unread notifications there are.\r\n        this.unreadCount = this.root.find(SELECTORS.COUNT_CONTAINER).html();\r\n    };\r\n\r\n    /**\r\n     * Clone the parent prototype.\r\n     */\r\n    NotificationPopoverController.prototype = Object.create(PopoverController.prototype);\r\n\r\n    /**\r\n     * Make sure the constructor is set correctly.\r\n     */\r\n    NotificationPopoverController.prototype.constructor = NotificationPopoverController;\r\n\r\n    /**\r\n     * Set the correct aria label on the menu toggle button to be read out by screen\r\n     * readers. The message will indicate the state of the unread notifications.\r\n     *\r\n     * @method updateButtonAriaLabel\r\n     */\r\n    NotificationPopoverController.prototype.updateButtonAriaLabel = function() {\r\n        if (this.isMenuOpen()) {\r\n            Str.get_string('hidenotificationwindow', 'message').done(function(string) {\r\n                this.menuToggle.attr('aria-label', string);\r\n                this.menuToggle.attr('title', string);\r\n            }.bind(this));\r\n        } else {\r\n            if (this.unreadCount) {\r\n                Str.get_string('shownotificationwindowwithcount', 'message_petel', this.unreadCount).done(function(string) {\r\n                    this.menuToggle.attr('aria-label', string);\r\n                    this.menuToggle.attr('title', string);\r\n                }.bind(this));\r\n            } else {\r\n                Str.get_string('shownotificationwindownonew', 'message_petel').done(function(string) {\r\n                    this.menuToggle.attr('aria-label', string);\r\n                    this.menuToggle.attr('title', string);\r\n                }.bind(this));\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Return the jQuery element with the content. This will return either\r\n     * the unread notification container or the all notification container\r\n     * depending on which is currently visible.\r\n     *\r\n     * @method getContent\r\n     * @return {object} jQuery object currently visible content contianer\r\n     */\r\n    NotificationPopoverController.prototype.getContent = function() {\r\n        return this.container;\r\n    };\r\n\r\n    /**\r\n     * Get the offset value for the current state of the popover in order\r\n     * to sent to the backend to correctly paginate the notifications.\r\n     *\r\n     * @method getOffset\r\n     * @return {int} current offset\r\n     */\r\n    NotificationPopoverController.prototype.getOffset = function() {\r\n        return this.offset;\r\n    };\r\n\r\n    /**\r\n     * Increment the offset for the current state, if required.\r\n     *\r\n     * @method incrementOffset\r\n     */\r\n    NotificationPopoverController.prototype.incrementOffset = function() {\r\n        this.offset += this.limit;\r\n    };\r\n\r\n    /**\r\n     * Check if the first load of notification has been triggered for the current\r\n     * state of the popover.\r\n     *\r\n     * @method hasDoneInitialLoad\r\n     * @return {bool} true if first notification loaded, false otherwise\r\n     */\r\n    NotificationPopoverController.prototype.hasDoneInitialLoad = function() {\r\n        return this.initialLoad;\r\n    };\r\n\r\n    /**\r\n     * Check if we've loaded all of the notifications for the current popover\r\n     * state.\r\n     *\r\n     * @method hasLoadedAllContent\r\n     * @return {bool} true if all notifications loaded, false otherwise\r\n     */\r\n    NotificationPopoverController.prototype.hasLoadedAllContent = function() {\r\n        return this.loadedAll;\r\n    };\r\n\r\n    /**\r\n     * Set the state of the loaded all content property for the current state\r\n     * of the popover.\r\n     *\r\n     * @method setLoadedAllContent\r\n     * @param {bool} val True if all content is loaded, false otherwise\r\n     */\r\n    NotificationPopoverController.prototype.setLoadedAllContent = function(val) {\r\n        this.loadedAll = val;\r\n    };\r\n\r\n    /**\r\n     * Show the unread notification count badge on the menu toggle if there\r\n     * are unread notifications, otherwise hide it.\r\n     *\r\n     * @method renderUnreadCount\r\n     */\r\n    NotificationPopoverController.prototype.renderUnreadCount = function() {\r\n        var element = this.root.find(SELECTORS.COUNT_CONTAINER);\r\n\r\n        if (this.unreadCount) {\r\n            element.text(this.unreadCount);\r\n            element.removeClass('hidden');\r\n        } else {\r\n            element.addClass('hidden');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Hide the unread notification count badge on the menu toggle.\r\n     *\r\n     * @method hideUnreadCount\r\n     */\r\n    NotificationPopoverController.prototype.hideUnreadCount = function() {\r\n        this.root.find(SELECTORS.COUNT_CONTAINER).addClass('hidden');\r\n    };\r\n\r\n    /**\r\n     * Find the notification element for the given id.\r\n     *\r\n     * @param {int} id\r\n     * @method getNotificationElement\r\n     * @return {object|null} The notification element\r\n     */\r\n    NotificationPopoverController.prototype.getNotificationElement = function(id) {\r\n        var element = this.root.find(SELECTORS.NOTIFICATION + '[data-id=\"' + id + '\"]');\r\n        return element.length == 1 ? element : null;\r\n    };\r\n\r\n    /**\r\n     * Render the notification data with the appropriate template and add it to the DOM.\r\n     *\r\n     * @method renderNotifications\r\n     * @param {array} notifications Notification data\r\n     * @param {object} container jQuery object the container to append the rendered notifications\r\n     * @return {object} jQuery promise that is resolved when all notifications have been\r\n     *                  rendered and added to the DOM\r\n     */\r\n    NotificationPopoverController.prototype.renderNotifications = function(notifications, container) {\r\n        var promises = [];\r\n\r\n        $.each(notifications, function(index, notification) {\r\n            // Determine what the offset was when loading this notification.\r\n            var offset = this.getOffset() - this.limit;\r\n            // Update the view more url to contain the offset to allow the notifications\r\n            // page to load to the correct position in the list of notifications.\r\n            notification.viewmoreurl = URL.relativeUrl('/message/output/petel/notifications.php', {\r\n                notificationid: notification.id,\r\n                offset: offset,\r\n            });\r\n\r\n            // Link to mark read page before loading the actual link.\r\n            var notificationurlparams = {\r\n                notificationid: notification.id\r\n            };\r\n            if (notification.contexturl) {\r\n                notificationurlparams.redirecturl = encodeURIComponent(notification.contexturl);\r\n            }else {\r\n                notification.contexturl = URL.relativeUrl('message/output/petel/mark_notification_read.php', notificationurlparams);\r\n            }\r\n\r\n            if(notification.customdata !== null) {\r\n                var customdata = JSON.parse(notification.customdata);\r\n                $.each(customdata, function(index, value) {\r\n                    notification[index] = value;\r\n                });\r\n            }\r\n\r\n            var promise = Templates.render('message_petel/notification_content_item', notification)\r\n            .then(function(html, js) {\r\n                return {html: html, js: js};\r\n            });\r\n            promises.push(promise);\r\n        }.bind(this));\r\n\r\n        return $.when.apply($, promises).then(function() {\r\n            // Each of the promises in the when will pass its results as an argument to the function.\r\n            // The order of the arguments will be the order that the promises are passed to when()\r\n            // i.e. the first promise's results will be in the first argument.\r\n            $.each(arguments, function(index, argument) {\r\n                container.append(argument.html);\r\n                Templates.runTemplateJS(argument.js);\r\n            });\r\n            return;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Send a request for more notifications from the server, if we aren't already\r\n     * loading some and haven't already loaded all of them.\r\n     *\r\n     * Takes into account the current mode of the popover and will request only\r\n     * unread notifications if required.\r\n     *\r\n     * All notifications are marked as read by the server when they are returned.\r\n     *\r\n     * @method loadMoreNotifications\r\n     * @return {object} jQuery promise that is resolved when notifications have been\r\n     *                        retrieved and added to the DOM\r\n     */\r\n    NotificationPopoverController.prototype.loadMoreNotifications = function() {\r\n        if (this.isLoading || this.hasLoadedAllContent()) {\r\n            return $.Deferred().resolve();\r\n        }\r\n\r\n        this.startLoading();\r\n        var request = {\r\n            limit: this.limit,\r\n            offset: this.getOffset(),\r\n            useridto: this.userId,\r\n        };\r\n\r\n        var container = this.getContent();\r\n        return NotificationRepo.query(request).then(function(result) {\r\n            var notifications = result.notifications;\r\n            this.unreadCount = result.unreadcount;\r\n            this.setLoadedAllContent(!notifications.length || notifications.length < this.limit);\r\n            this.initialLoad = true;\r\n            this.updateButtonAriaLabel();\r\n\r\n            if (notifications.length) {\r\n                this.incrementOffset();\r\n                return this.renderNotifications(notifications, container);\r\n            }\r\n\r\n            return false;\r\n        }.bind(this))\r\n        .always(function() {\r\n            this.stopLoading();\r\n        }.bind(this));\r\n    };\r\n\r\n    /**\r\n     * Send a request to the server to mark all unread notifications as read and update\r\n     * the unread count and unread notification elements appropriately.\r\n     *\r\n     * @return {Promise}\r\n     * @method markAllAsRead\r\n     */\r\n    NotificationPopoverController.prototype.markAllAsRead = function() {\r\n        this.markAllReadButton.addClass('loading');\r\n\r\n        return NotificationRepo.markAllAsRead({useridto: this.userId})\r\n            .then(function() {\r\n                this.unreadCount = 0;\r\n                this.root.find(SELECTORS.UNREAD_NOTIFICATION).removeClass('unread');\r\n            }.bind(this))\r\n            .always(function() {\r\n                this.markAllReadButton.removeClass('loading');\r\n            }.bind(this));\r\n    };\r\n\r\n    /**\r\n     * Add all of the required event listeners for this notification popover.\r\n     *\r\n     * @method registerEventListeners\r\n     */\r\n    NotificationPopoverController.prototype.registerEventListeners = function() {\r\n        CustomEvents.define(this.root, [\r\n            CustomEvents.events.activate,\r\n        ]);\r\n\r\n        // Mark all notifications read if the user activates the mark all as read button.\r\n        this.root.on(CustomEvents.events.activate, SELECTORS.MARK_ALL_READ_BUTTON, function(e, data) {\r\n            this.markAllAsRead();\r\n            e.stopPropagation();\r\n            data.originalEvent.preventDefault();\r\n        }.bind(this));\r\n\r\n        // Mark individual notification read if the user activates it.\r\n        this.root.on(CustomEvents.events.activate, SELECTORS.NOTIFICATION_LINK, function(e) {\r\n            var element = $(e.target).closest(SELECTORS.NOTIFICATION);\r\n\r\n            if (element.hasClass('unread')) {\r\n                this.unreadCount--;\r\n                element.removeClass('unread');\r\n            }\r\n\r\n            e.stopPropagation();\r\n        }.bind(this));\r\n\r\n        // Update the notification information when the menu is opened.\r\n        this.root.on(this.events().menuOpened, function() {\r\n            this.hideUnreadCount();\r\n            this.updateButtonAriaLabel();\r\n\r\n            if (!this.hasDoneInitialLoad()) {\r\n                this.loadMoreNotifications();\r\n            }\r\n        }.bind(this));\r\n\r\n        // Update the unread notification count when the menu is closed.\r\n        this.root.on(this.events().menuClosed, function() {\r\n\r\n            var request = {\r\n                limit: this.limit,\r\n                offset: this.getOffset(),\r\n                useridto: this.userId,\r\n            };\r\n\r\n            return NotificationRepo.query(request).then(function(result) {\r\n                this.unreadCount = result.unreadcount;\r\n\r\n                this.renderUnreadCount();\r\n                this.updateButtonAriaLabel();\r\n\r\n                return false;\r\n            }.bind(this))\r\n                .always(function() {\r\n\r\n                }.bind(this));\r\n        }.bind(this));\r\n\r\n        // Set aria attributes when popover is loading.\r\n        this.root.on(this.events().startLoading, function() {\r\n            this.getContent().attr('aria-busy', 'true');\r\n        }.bind(this));\r\n\r\n        // Set aria attributes when popover is finished loading.\r\n        this.root.on(this.events().stopLoading, function() {\r\n            this.getContent().attr('aria-busy', 'false');\r\n        }.bind(this));\r\n\r\n        // Load more notifications if the user has scrolled to the end of content\r\n        // item list.\r\n        this.getContentContainer().on(CustomEvents.events.scrollBottom, function() {\r\n            if (!this.isLoading && !this.hasLoadedAllContent()) {\r\n                this.loadMoreNotifications();\r\n            }\r\n        }.bind(this));\r\n\r\n        // Stop mouse scroll from propagating to the window element and\r\n        // scrolling the page.\r\n        CustomEvents.define(this.getContentContainer(), [\r\n            CustomEvents.events.scrollLock\r\n        ]);\r\n\r\n        // Listen for when a notification is shown in the notifications page and mark\r\n        // it as read, if it's unread.\r\n        $(document).on(NotificationAreaEvents.notificationShown, function(e, notification) {\r\n            if (!notification.read) {\r\n                var element = this.getNotificationElement(notification.id);\r\n\r\n                if (element) {\r\n                    element.removeClass('unread');\r\n                }\r\n\r\n                this.unreadCount--;\r\n                this.renderUnreadCount();\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    return NotificationPopoverController;\r\n});\r\n"],"names":["define","$","Ajax","Templates","Str","URL","DebugNotification","CustomEvents","PopoverController","NotificationRepo","NotificationAreaEvents","SELECTORS","NotificationPopoverController","element","call","this","markAllReadButton","root","find","unreadCount","userId","attr","container","limit","offset","loadedAll","initialLoad","html","prototype","Object","create","constructor","updateButtonAriaLabel","isMenuOpen","get_string","done","string","menuToggle","bind","getContent","getOffset","incrementOffset","hasDoneInitialLoad","hasLoadedAllContent","setLoadedAllContent","val","renderUnreadCount","text","removeClass","addClass","hideUnreadCount","getNotificationElement","id","length","renderNotifications","notifications","promises","each","index","notification","viewmoreurl","relativeUrl","notificationid","notificationurlparams","contexturl","redirecturl","encodeURIComponent","customdata","JSON","parse","value","promise","render","then","js","push","when","apply","arguments","argument","append","runTemplateJS","loadMoreNotifications","isLoading","Deferred","resolve","startLoading","request","useridto","query","result","unreadcount","always","stopLoading","markAllAsRead","registerEventListeners","events","activate","on","e","data","stopPropagation","originalEvent","preventDefault","target","closest","hasClass","menuOpened","menuClosed","getContentContainer","scrollBottom","scrollLock","document","notificationShown","read"],"mappings":"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"}