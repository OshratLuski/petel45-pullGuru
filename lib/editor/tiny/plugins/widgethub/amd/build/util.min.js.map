{"version":3,"file":"util.min.js","sources":["../src/util.js"],"sourcesContent":["/* eslint-disable no-console */\r\n/* eslint-disable no-eq-null */\r\n/* eslint-disable no-bitwise */\r\n/* eslint-disable no-new-func */\r\n// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Tiny WidgetHub plugin.\r\n *\r\n * @module      tiny_widgethub/plugin\r\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\r\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\n/**\r\n * @returns {string} a randomID\r\n */\r\nexport function genID() {\r\n    return 'g' + Math.random().toString(32).substring(2);\r\n}\r\n\r\n/**\r\n * @param {Object.<string, any>} ctx\r\n * @param {string} expr\r\n * @param {boolean=} keepFns - Keep or not the funcions in the ctx\r\n * @returns {any} The evaluated expression within the context ctx\r\n */\r\nexport function evalInContext(ctx, expr, keepFns) {\r\n    const listArgs = [];\r\n    const listVals = [];\r\n\r\n    if (ctx) {\r\n        Object.keys(ctx).forEach((key) => {\r\n            // Remove functions from ctx\r\n            if (keepFns || typeof ctx[key] !== \"function\") {\r\n                listArgs.push(key);\r\n                listVals.push(ctx[key]);\r\n            }\r\n        });\r\n    }\r\n    listArgs.push('expr');\r\n    listArgs.push('return eval(expr)');\r\n    listVals.push(expr);\r\n    const evaluator = new Function(...listArgs);\r\n    return evaluator(...listVals);\r\n}\r\n\r\n/**\r\n * @param {string} s - string to the hashed\r\n * @returns {number}\r\n */\r\nexport function hashCode(s) {\r\n    s = s || \"\";\r\n    let h = 0;\r\n    const l = s.length;\r\n    let i = 0;\r\n    if (l > 0) {\r\n        while (i < l) {\r\n            h = (h << 6) + ((s.charCodeAt(i) - 65) | 0);\r\n            i++;\r\n        }\r\n    }\r\n    return Math.abs(h);\r\n}\r\n\r\n/**\r\n * @param {string} str1\r\n * @param {string} needle\r\n * @returns {boolean} Whether str1 contains needle or not\r\n */\r\nexport function searchComp(str1, needle) {\r\n    str1 = (str1 || '').trim().toLowerCase();\r\n    needle = (needle || '').trim().toLowerCase();\r\n    str1 = str1.replace(/[àáâãäå]/, \"a\")\r\n        .replace(/[èéêë]/, \"e\")\r\n        .replace(/[ìíîï]/, \"i\")\r\n        .replace(/[òóôö]/, \"o\")\r\n        .replace(/[ùúüû]/, \"u\")\r\n        .replace(/ç/, \"c\")\r\n        .replace(/·/, \"\");\r\n    needle = needle.replace(/[àáâãäå]/, \"a\")\r\n        .replace(/[èéêë]/, \"e\")\r\n        .replace(/[ìíîï]/, \"i\")\r\n        .replace(/[òóôö]/, \"o\")\r\n        .replace(/[ùúüû]/, \"u\")\r\n        .replace(/ç/, \"c\")\r\n        .replace(/·/, \"\");\r\n    return str1.indexOf(needle) >= 0;\r\n}\r\n\r\n/** Default transformers */\r\nconst Transformers = {\r\n    /** @param {string} txt */\r\n    toUpperCase: function(txt) {\r\n        return (txt + \"\").toUpperCase();\r\n    },\r\n    /** @param {string} txt */\r\n    toLowerCase: function(txt) {\r\n        return (txt + \"\").toLowerCase();\r\n    },\r\n   /** @param {string} txt */\r\n    trim: function(txt) {\r\n        return (txt + \"\").trim();\r\n    },\r\n    /** @param {string} txt */\r\n    ytId: function(txt) {\r\n        // Finds the youtubeId in a text\r\n        const rx = /^.*(?:(?:youtu\\.be\\/|v\\/|vi\\/|u\\/\\w\\/|embed\\/|shorts\\/)|(?:(?:watch)?\\?v(?:i)?=|&v(?:i)?=))([^#&?]*).*/;\r\n        const r = (txt || '').match(rx);\r\n        if (r?.length) {\r\n            return r[1];\r\n        }\r\n        return txt;\r\n    },\r\n    /** @param {string} txt */\r\n    vimeoId: function(txt) {\r\n        const regExp = /^.*(vimeo\\.com\\/)((channels\\/[A-z]+\\/)|(groups\\/[A-z]+\\/videos\\/))?(\\d+)/;\r\n        const match = new RegExp(regExp).exec(txt || \"\");\r\n        if (match?.[5]) {\r\n            return match[5];\r\n        }\r\n        return txt;\r\n    },\r\n    /** @param {string} txt */\r\n    serveGDrive: function(txt) {\r\n        // Expecting https://drive.google.com/file/d/1DDUzcFrOlzWb3CBdFPJ1NCNXClvPbm5B/preview\r\n        const res = (txt + \"\").match(/https:\\/\\/drive.google.com\\/file\\/d\\/([a-zA-Z0-9_]+)\\//);\r\n        if (res?.length) {\r\n            const driveId = res[1];\r\n            return \"https://docs.google.com/uc?export=open&id=\" + driveId;\r\n        }\r\n        return txt;\r\n    },\r\n    /** @param {string} txt */\r\n    removeHTML: function(txt) {\r\n        return (txt || '').replace(/<[^>]*>?/gm, '');\r\n    },\r\n    /** @param {string} txt */\r\n    escapeHTML: function(txt) {\r\n        return (txt || '').replace(/&/g, \"&amp;\")\r\n            .replace(/</g, \"&lt;\")\r\n            .replace(/>/g, \"&gt;\")\r\n            .replace(/\"/g, \"&quot;\")\r\n            .replace(/'/g, \"&#039;\");\r\n    },\r\n   /** @param {string} txt */\r\n    encodeHTML: function(txt) {\r\n        // @ts-ignore\r\n        return encodeURIComponent(txt || \"\");\r\n    },\r\n    /** @param {string} txt */\r\n    escapeQuotes: function(txt) {\r\n        return (txt || '').replace(/\"/gm, \"'\");\r\n    }\r\n};\r\n\r\n\r\nclass Builder {\r\n    transSeq;\r\n    // @ts-ignore\r\n    constructor(transformStr) {\r\n        const parts = transformStr.split('|');\r\n        this.transSeq = [];\r\n        for (let j = 0, lenj = parts.length; j < lenj; j++) {\r\n            const prts = parts[j].trim();\r\n            // @ts-ignore\r\n            const transfunc = Transformers[prts];\r\n            if (transfunc != null) {\r\n                this.transSeq.push(transfunc);\r\n            } else {\r\n                console.error(\"Cannot find transformer named \" + prts);\r\n            }\r\n        }\r\n    }\r\n\r\n    // @ts-ignore\r\n    reduce(text) {\r\n        for (let j = 0, lenj = this.transSeq.length; j < lenj; j++) {\r\n            const transfunc = this.transSeq[j];\r\n            text = transfunc(text);\r\n        }\r\n        return text;\r\n    }\r\n}\r\n\r\n/**\r\n * @param {string} transformStr\r\n * @returns {Builder} call reduce(text) function\r\n */\r\nexport function stream(transformStr) {\r\n    return new Builder(transformStr);\r\n}\r\n\r\n/**\r\n * @param {string} name\r\n * @returns {string} Replaces $ apperences by _ to make the name compatible by data attributes\r\n */\r\nexport function cleanParameterName(name) {\r\n    return name.replace(/\\$/g, '_');\r\n}\r\n\r\n/**\r\n * Creates a filter funcion from filterCode\r\n * @param {string} filterCode\r\n * @returns {Function?}\r\n */\r\nexport function createFilterFunction(filterCode) {\r\n    let userWidgetFilter = null;\r\n    try {\r\n        userWidgetFilter = new Function('text', 'editor', 'opts', filterCode);\r\n    } catch (ex) {\r\n        userWidgetFilter = null;\r\n        console.error(ex);\r\n    }\r\n    return userWidgetFilter;\r\n}\r\n\r\n/**\r\n * @param {import('./plugin').TinyMCE} editor\r\n * @param {{get_strings: (keyComponent: any[]) => Promise<string[]>}} coreStr - dependency on core/str\r\n * @returns {*}\r\n */\r\nexport function applyWidgetFilterFactory(editor, coreStr) {\r\n    /**\r\n     * @param {string} widgetTemplate\r\n     * @param {boolean} silent\r\n     * @param {object?} mergevars\r\n     * @returns {Promise<boolean>} - True if the filter can be compiled\r\n     */\r\n    return async(widgetTemplate, silent, mergevars) => {\r\n        const translations = await coreStr.get_strings([\r\n            {key: 'filterres', component: 'tiny_widgethub'},\r\n            {key: 'nochanges', component: 'tiny_widgethub'}\r\n        ]);\r\n        // Es tracta d'un filtre, no d'un widget i s'ha de tractar de forma diferent\r\n        const userWidgetFilter = createFilterFunction(widgetTemplate);\r\n\r\n        if (!userWidgetFilter) {\r\n            editor.notificationManager.open({\r\n                text: translations[0] + \": Invalid filter\",\r\n                type: 'danger',\r\n                timeout: 4000\r\n            });\r\n            return false;\r\n        }\r\n        // @ts-ignore\r\n        const handleFilterResult = function(res) {\r\n            const out = res[0];\r\n            let msg = res[1];\r\n            if (out != null) {\r\n                if (typeof out === \"string\") {\r\n                    editor.setContent(out);\r\n                    editor.notificationManager.open({\r\n                        text: translations[0] + \": \" + msg,\r\n                        type: 'success',\r\n                        timeout: 5000\r\n                    });\r\n                } else if (out === true) {\r\n                    editor.notificationManager.open({\r\n                        text: translations[0] + \": \" + msg,\r\n                        type: 'success',\r\n                        timeout: 5000\r\n                    });\r\n                } else if (out === false && !silent) {\r\n                    editor.notificationManager.open({\r\n                        text: translations[1],\r\n                        type: 'info',\r\n                        timeout: 5000\r\n                    });\r\n                }\r\n            } else if (!silent) {\r\n                editor.notificationManager.open({\r\n                    text: translations[1],\r\n                    type: 'info',\r\n                    timeout: 5000\r\n                });\r\n            }\r\n        };\r\n\r\n        const initialHTML = editor.getContent();\r\n        const filteredResult = userWidgetFilter(initialHTML, editor, mergevars);\r\n        // Hi ha la possibilitat que el filtre retorni una promesa o un array\r\n        const isPromise = filteredResult != null && typeof (filteredResult) === 'object' && ('then' in filteredResult);\r\n        if (isPromise) {\r\n            filteredResult.then(handleFilterResult).catch((/** @type {any} */ err) => console.error(err));\r\n        } else {\r\n            handleFilterResult(filteredResult || [null, translations[1]]);\r\n        }\r\n        return true;\r\n    };\r\n}\r\n\r\n/**\r\n * Safe conversion of a string to integer by handling errors and NaN values\r\n * In this case, the def number passed is returned\r\n * @param {string | undefined | null | number} str\r\n * @param {number} def - default value\r\n * @returns {number}\r\n */\r\nexport function convertInt(str, def) {\r\n    if (str && typeof str === 'number') {\r\n        return Math.floor(str);\r\n    }\r\n    if (!str || !(str + \"\").trim() || !RegExp(/^\\s*[+-]?\\d+(\\.\\d*)?\\s*$/).exec(str + \"\")) {\r\n        return def;\r\n    }\r\n    try {\r\n        const val = parseInt(str + \"\");\r\n        if (!isNaN(val)) {\r\n            return val;\r\n        }\r\n    } catch (ex) {\r\n        // Pass\r\n    }\r\n    return def;\r\n}\r\n\r\n/**\r\n * Finds the parameter with a given name within the list of objects\r\n * @param {string} varname\r\n * @param {import('./options').Param[]} listVars\r\n * @returns {import('./options').Param | null}\r\n */\r\nexport function findVariableByName(varname, listVars) {\r\n    if (!listVars) {\r\n        return null;\r\n    }\r\n    let found = null;\r\n    const len = listVars.length;\r\n    let k = 0;\r\n    while (k < len && !found) {\r\n        if (listVars[k].name === varname) {\r\n            found = listVars[k];\r\n        }\r\n        k++;\r\n    }\r\n    return found;\r\n}\r\n\r\n/**\r\n * Safely joins two parts of an url\r\n * @param {string} a\r\n * @param {string=} b\r\n * @returns {string}\r\n */\r\nexport function pathJoin(a, b) {\r\n    a = (a || \"\").trim();\r\n    b = (b || \"\").trim();\r\n    if (!a.endsWith('/')) {\r\n        a = a + '/';\r\n    }\r\n    if (b.startsWith('/')) {\r\n        b = b.substring(1);\r\n    }\r\n    return a + b;\r\n}\r\n\r\n/**\r\n * Adds the baseurl if the passed url does not start with http or https\r\n * @param {string} base\r\n * @param {string=} url\r\n * @returns {string}\r\n */\r\nexport function addBaseToUrl(base, url) {\r\n    url = (url || \"\").trim();\r\n    if (url.toLowerCase().startsWith(\"http\")) {\r\n        return url;\r\n    }\r\n    // Afegir la base\r\n    const out = pathJoin(base, url);\r\n    return out;\r\n}\r\n\r\n/**\r\n * @param {*} value\r\n * @param {string | undefined} type\r\n * @returns {*}\r\n */\r\nexport const performCasting = function(value, type) {\r\n    if (!type || typeof value === type) {\r\n        return value;\r\n    }\r\n    switch (type) {\r\n        case (\"boolean\"):\r\n            if (value === 1 || value === \"1\" || value === true || value === \"true\") {\r\n                value = true;\r\n            } else {\r\n                value = false;\r\n            }\r\n            break;\r\n        case (\"number\"):\r\n            try {\r\n                let parsed;\r\n                if ((value + '').indexOf(\".\") < 0) {\r\n                    parsed = parseInt(value);\r\n                } else {\r\n                    parsed = parseFloat(value);\r\n                }\r\n                if (!isNaN(parsed)) {\r\n                    value = parsed;\r\n                } else {\r\n                    value = 0;\r\n                    console.error(`Error parsing number ${value}`);\r\n                }\r\n            } catch (ex) {\r\n                value = 0;\r\n                console.error(`Error parsing number ${value}`);\r\n            }\r\n            break;\r\n        case (\"string\"):\r\n            if (typeof value === 'object') {\r\n                value = JSON.stringify(value);\r\n            } else {\r\n                value = value + \"\";\r\n            }\r\n            break;\r\n        default:\r\n            console.error(`Fail to cast ${value} to ${type}`);\r\n    }\r\n    return value;\r\n};\r\n\r\n/**\r\n * @param {unknown} a\r\n * @param {unknown} b\r\n */\r\nconst xor = function(a, b) {\r\n    return !a !== !b;\r\n};\r\n\r\n/**\r\n * @param {string} str\r\n * @param {*} match\r\n * @param {string} replacement\r\n * @returns {string}\r\n */\r\nconst replaceStrPart = function(str, match, replacement) {\r\n    if (!match.indices) {\r\n        console.error(\"RegExp match does not include indices\");\r\n        return str;\r\n    }\r\n    const [a, b] = match.indices[1];\r\n    return str.substring(0, a) + replacement + str.substring(b);\r\n};\r\n\r\n/**\r\n * Replaces the first capturing group in regexExpr by replacement,\r\n * The remaining capturing groups are removed.\r\n * @param {string} regexExpr\r\n * @param {string} replacement\r\n * @returns {string}\r\n */\r\nconst getValueFromRegex = function(regexExpr, replacement) {\r\n    const reParser = /\\((?!\\?:).*?\\)/g;\r\n    let capturingGroupCount = 0;\r\n    return regexExpr.replace(reParser, () => {\r\n        capturingGroupCount++;\r\n        if (capturingGroupCount === 1) {\r\n            return replacement + '';\r\n        }\r\n        return \"\"; // Remove all other capturing groups\r\n    });\r\n};\r\n\r\n/**\r\n * @param {JQuery<HTMLElement>} $e - The target element\r\n * @returns\r\n */\r\nconst bindingFactory = function($e) {\r\n    /** @this {Record<string, Function>} */\r\n    const methods = {\r\n        /**\r\n         * @param {string} className\r\n         * @param {string=} query\r\n         * @param {boolean=} neg\r\n         * @returns {Binding}\r\n         */\r\n        hasClass: (className, query, neg) => {\r\n            /** @type {JQuery<HTMLElement>} */\r\n            let elem = $e;\r\n            if (query) {\r\n                elem = $e.find(query);\r\n            }\r\n            return {\r\n                // @ts-ignore\r\n                getValue: () => {\r\n                    const res = xor(neg, elem.hasClass(className));\r\n                    return Boolean(res);\r\n                },\r\n                // @ts-ignore\r\n                setValue: (bool) => {\r\n                    if (xor(neg, bool)) {\r\n                        elem.addClass(className);\r\n                    } else {\r\n                        elem.removeClass(className);\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        /**\r\n         * @param {string} className\r\n         * @param {string=} query\r\n         * @returns {Binding}\r\n         */\r\n        notHasClass: (className, query) => {\r\n            return methods.hasClass(className, query, true);\r\n        },\r\n        /**\r\n         * @param {string} classExpr\r\n         * @param {string=} query\r\n         * @param {string=} castTo\r\n         * @returns {Binding}\r\n         */\r\n        classRegex: (classExpr, query, castTo) => {\r\n            let elem = $e;\r\n            if (query) {\r\n                elem = $e.find(query);\r\n            }\r\n            return {\r\n                getValue: () => {\r\n                    let ret = '';\r\n                    const classes = (elem.attr('class') ?? '').split(' ');\r\n                    for (const clazz of classes) {\r\n                        const match = new RegExp(classExpr).exec(clazz);\r\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\r\n                            ret = match[1];\r\n                            break;\r\n                        }\r\n                    }\r\n                    return performCasting(ret, castTo);\r\n                },\r\n                setValue: (val) => {\r\n                    const cl = elem.attr('class')?.split(/\\s+/) ?? [];\r\n                    let found = false;\r\n                    cl.forEach(c => {\r\n                        const match = new RegExp(classExpr, 'd').exec(c);\r\n                        if (match === null) {\r\n                            return;\r\n                        }\r\n                        found = true;\r\n                        elem.removeClass(c);\r\n                        const newCls = replaceStrPart(c, match, val + '');\r\n                        elem.addClass(newCls);\r\n                    });\r\n                    // If not found, then set the regExp replacing the\r\n                    // first capturing group with val, and removing the remaining groups.\r\n                    if (!found) {\r\n                        const newCls = getValueFromRegex(classExpr, val + '');\r\n                        elem.addClass(newCls);\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        /**\r\n         * @param {string} attrName\r\n         * @param {string=} query\r\n         * @param {string=} castTo\r\n         * @returns {Binding}\r\n         */\r\n        attr: (attrName, query, castTo) => {\r\n            let elem = $e;\r\n            if (query) {\r\n                elem = $e.find(query);\r\n            }\r\n            return {\r\n                getValue: () => {\r\n                    return performCasting(elem.attr(attrName), castTo);\r\n                },\r\n                // @ts-ignore\r\n                setValue: (val) => {\r\n                    if (typeof val === \"boolean\") {\r\n                        val = val ? 1 : 0;\r\n                    }\r\n                    const attrVal = val + '';\r\n                    elem.attr(attrName, attrVal);\r\n                    if (attrName === 'href' || attrName === 'src') {\r\n                        elem.attr('data-mce-' + attrName, attrVal);\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        /**\r\n         * @param {string} attr\r\n         * @param {string=} query\r\n         * @param {boolean=} neg\r\n         * @returns {Binding}\r\n         */\r\n        hasAttr: (attr, query, neg) => {\r\n            let elem = $e;\r\n            if (query) {\r\n                elem = $e.find(query);\r\n            }\r\n            const parts = attr.split(\"=\");\r\n            const attrName = parts[0].trim();\r\n            let attrValue = '';\r\n            if (parts.length > 1) {\r\n                attrValue = parts[1].trim();\r\n            }\r\n            return {\r\n                getValue: () => {\r\n                    let found = elem.attr(attrName) != null;\r\n                    if (attrValue) {\r\n                        found = found && elem.attr(attrName) === attrValue;\r\n                    }\r\n                    return xor(neg, found);\r\n                },\r\n                // @ts-ignore\r\n                setValue: (bool) => {\r\n                    if (xor(neg, bool)) {\r\n                        elem.attr(attrName, attrValue || '');\r\n                        if (attrName === 'href' || attrName === 'src') {\r\n                            elem.attr('data-mce-' + attrName, attrValue + '');\r\n                        }\r\n                    } else {\r\n                        elem.removeAttr(attrName);\r\n                        if (attrName === 'href' || attrName === 'src') {\r\n                            elem.removeAttr('data-mce-' + attrName);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        /**\r\n         * @param {string} attr\r\n         * @param {string=} query\r\n         * @returns {Binding}\r\n         */\r\n        notHasAttr: (attr, query) => {\r\n            return methods.hasAttr(attr, query, true);\r\n        },\r\n        /**\r\n         * @param {string} attr - Regex of attr\r\n         * @param {string=} query\r\n         * @param {string=} castTo\r\n         * @returns {Binding}\r\n         */\r\n        attrRegex: function(attr, query, castTo) {\r\n            let elem = $e;\r\n            if (query) {\r\n                elem = $e.find(query);\r\n            }\r\n            const parts = attr.split(\"=\");\r\n            const attrName = parts[0].trim();\r\n            let attrValue = '';\r\n            if (parts.length > 1) {\r\n                attrValue = parts[1].trim();\r\n            }\r\n            return {\r\n                getValue() {\r\n                    const found = elem.attr(attrName) != null;\r\n                    if (found) {\r\n                        const match = elem.attr(attrName)?.match(attrValue);\r\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\r\n                            return performCasting(match[1], castTo);\r\n                        }\r\n                        return '';\r\n                    }\r\n                    return null;\r\n                },\r\n                setValue(val) {\r\n                    const oldValue = elem.attr(attrName) ?? '';\r\n                    const match = new RegExp(attrValue, 'd').exec(oldValue);\r\n                    let newValue;\r\n                    if (match) {\r\n                        newValue = replaceStrPart(oldValue, match, val + '');\r\n                    } else {\r\n                        newValue = getValueFromRegex(attrValue, val + '');\r\n                    }\r\n                    elem.attr(attrName, newValue);\r\n                    if (attrName === 'href' || attrName === 'src') {\r\n                        elem.attr('data-mce-' + attrName, newValue + '');\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        /**\r\n         * @param {string} sty\r\n         * @param {string=} query\r\n         * @param {boolean=} neg\r\n         * @returns {Binding}\r\n         */\r\n        hasStyle: function(sty, query, neg) {\r\n            let elem = $e;\r\n            if (query) {\r\n                elem = $e.find(query);\r\n            }\r\n            const parts = sty.split(\":\");\r\n            let styName = parts[0].trim();\r\n            /** @type {string | undefined} */\r\n            let styValue;\r\n            if (parts.length > 1) {\r\n                styValue = parts[1].trim();\r\n            }\r\n            return {\r\n                getValue() {\r\n                    const st = elem.prop('style');\r\n                    const pValue = st.getPropertyValue(styName);\r\n                    const has = styValue === undefined ? pValue !== '' : pValue === styValue;\r\n                    return xor(has, neg);\r\n                },\r\n                // @ts-ignore\r\n                setValue(bool) {\r\n                    if (xor(bool, neg)) {\r\n                        elem.css(styName, styValue ?? '');\r\n                    } else {\r\n                        const st = elem.prop('style');\r\n                        st.removeProperty(styName);\r\n                    }\r\n                    // TODO: better way to update data-mce-style\r\n                    elem.attr('data-mce-style', elem[0].style.cssText);\r\n                }\r\n            };\r\n        },\r\n        /**\r\n         * @param {string} sty\r\n         * @param {string=} query\r\n         * @returns {Binding}\r\n         */\r\n        notHasStyle: (sty, query) => {\r\n            return methods.hasStyle(sty, query, true);\r\n        },\r\n        /**\r\n         * @param {string} attr - styName:styValue where styValue is a regex with (.*)\r\n         * @param {string=} query\r\n         * @param {string=} castTo\r\n         * @returns {Binding}\r\n         */\r\n        styleRegex: function(attr, query, castTo) {\r\n            let elem = $e;\r\n            if (query) {\r\n                elem = $e.find(query);\r\n            }\r\n            const parts = attr.split(\":\");\r\n            const styName = parts[0].trim();\r\n            let styValue = '';\r\n            if (parts.length > 1) {\r\n                styValue = parts[1].trim();\r\n            }\r\n            return {\r\n                /** @returns {string | null} */\r\n                getValue() {\r\n                    const st = elem.prop('style');\r\n                    const currentVal = st?.getPropertyValue(styName);\r\n                    if (currentVal) {\r\n                        if (styValue) {\r\n                            const match = new RegExp(styValue).exec(currentVal);\r\n                            if (match?.[1] && (typeof match[1]) === \"string\") {\r\n                                return performCasting(match[1], castTo);\r\n                            }\r\n                        } else {\r\n                            return performCasting(currentVal, castTo);\r\n                        }\r\n                    }\r\n                    return performCasting('', castTo);\r\n                },\r\n                // @ts-ignore\r\n                setValue(val) {\r\n                    let newValue;\r\n                    if (styValue) {\r\n                        // Case val <= 0 && styName contains width or height\r\n                        if ((styName.includes(\"width\") || styName.includes(\"height\")) && (parseFloat(val + '') <= 0)) {\r\n                            newValue = '';\r\n                        } else {\r\n                            const oldValue = elem.prop('style').getPropertyValue(styName) ?? '';\r\n                            if (oldValue) {\r\n                                const match = new RegExp(styValue, 'd').exec(oldValue);\r\n                                // @ts-ignore\r\n                                newValue = replaceStrPart(oldValue, match, val + '');\r\n                            } else {\r\n                                newValue = styValue.replace('(.*)', val + '');\r\n                            }\r\n                        }\r\n                    } else {\r\n                        newValue = val + '';\r\n                    }\r\n                    elem.css(styName, newValue);\r\n                    // TODO: better way to update data-mce-style\r\n                    elem.attr('data-mce-style', elem[0].style.cssText);\r\n                }\r\n            };\r\n        }\r\n    };\r\n    return methods;\r\n};\r\n\r\n/**\r\n * @typedef {Object} Binding\r\n * @property {() => unknown} getValue\r\n * @property {(value: string | boolean | number) => void} setValue\r\n */\r\n/**\r\n * @param {string | {get: string, set: string}} definition\r\n * @param {JQuery<HTMLElement>} elem  - The root of widget\r\n * @param {string=} castTo  - The type that must be returned\r\n * @returns {Binding | null}\r\n */\r\nexport const createBinding = (definition, elem, castTo) => {\r\n    /** @type {Binding | null} */\r\n    let bindFn = null;\r\n    if (typeof (definition) === 'string') {\r\n        return evalInContext({...bindingFactory(elem)}, definition, true);\r\n    } else {\r\n        // The user provides the get and set functions\r\n        bindFn = {\r\n            getValue: () => {\r\n                let v = evalInContext({elem}, `(${definition.get})(elem)`);\r\n                if (castTo) {\r\n                    v = performCasting(v, castTo);\r\n                }\r\n                return v;\r\n            },\r\n            setValue: (v) => evalInContext({elem, v}, `(${definition.set})(elem, v)`)\r\n        };\r\n    }\r\n    return bindFn;\r\n};\r\n\r\n/**\r\n * Capitalizes the first letter of a string\r\n * @param {string | undefined | null} s\r\n * @returns {string}\r\n */\r\nexport const capitalize = s => (s && s[0].toUpperCase() + s.slice(1)) || \"\";\r\n\r\n/**\r\n * @param {string | null | undefined} color - color in hex or rgb or rgba\r\n * @returns {[string, number]} - The color in hex format, alpha channel 0..1\r\n */\r\nexport function toHexAlphaColor(color) {\r\n    color = (color || '#000000').trim().toLowerCase();\r\n    let alpha = 1;\r\n    if (color.startsWith(\"#\") && color.length === 9) {\r\n        // Already in hex & alpha\r\n        alpha = parseInt('0x' + color.substring(7)) / 255.0;\r\n        color = color.substring(0, 7);\r\n    } else if (color.startsWith('rgb')) {\r\n        // Assume rgb or rgba\r\n        const sep = color.indexOf(\",\") > -1 ? \",\" : \" \";\r\n        const a = color.replace(/[^\\d,]/g, \"\").split(sep);\r\n        color = \"#\" + ((1 << 24) + (+a[0] << 16) + (+a[1] << 8) + (+a[2])).toString(16).slice(1);\r\n        // Is rgba?\r\n        if (a.length === 4) {\r\n            alpha = +a[3];\r\n            if (alpha > 1) {\r\n                alpha = 0.01 * alpha;\r\n            }\r\n        }\r\n    }\r\n    return [color, alpha];\r\n}\r\n\r\n/**\r\n * @param {string | null | undefined} hex - color in hex\r\n * @param {number} alpha - 0..1 or 0..100\r\n * @returns {string} - The color in rgba syntax\r\n */\r\nexport function toRgba(hex, alpha) {\r\n    hex = (hex || '#000000').trim().toLowerCase();\r\n    /** @type {number | string} */\r\n    let alpha2 = alpha ?? 1;\r\n    if (alpha2 > 1) {\r\n        alpha2 *= 0.01;\r\n    }\r\n    if (alpha2 !== 0 && alpha2 !== 1) {\r\n        alpha2 = alpha2.toFixed(2);\r\n    }\r\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})/i.exec(hex);\r\n    let r = 0,\r\n        g = 0,\r\n        b = 0;\r\n    if (result) {\r\n      r = parseInt(result[1], 16);\r\n      g = parseInt(result[2], 16);\r\n      b = parseInt(result[3], 16);\r\n    }\r\n    if (alpha === 1) {\r\n        return `rgb(${r},${g},${b})`;\r\n    }\r\n    return `rgba(${r},${g},${b},${alpha2})`;\r\n}\r\n\r\n/**\r\n * Simple debounce function\r\n * @param {(evt?: any) => void} cb\r\n * @param {number} [delay]\r\n */\r\n/**\r\n * Simple debounce function\r\n * @param {(...args: unknown[]) => void} cb\r\n * @param {number} [delay]\r\n * @returns {((...args: unknown[]) => void) & {clear: () => void}}\r\n */\r\nexport function debounce(cb, delay = 1000) {\r\n    /** @type{number | null} */\r\n    let timeoutId = null;\r\n    const debounced = (/** @type {unknown[]} */ ...args) => {\r\n        if (timeoutId) {\r\n            window.clearTimeout(timeoutId);\r\n        }\r\n        timeoutId = window.setTimeout(() => {\r\n          cb(...args);\r\n        }, delay);\r\n    };\r\n    debounced.clear = () => {\r\n        if (!timeoutId) {\r\n            return;\r\n        }\r\n        window.clearTimeout(timeoutId);\r\n        timeoutId = null;\r\n    };\r\n    return debounced;\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} elem\r\n * @param {...string} classNames\r\n */\r\nexport function toggleClass(elem, ...classNames) {\r\n    const classList = elem.classList;\r\n    classNames.forEach(name => {\r\n        if (classList.contains(name)) {\r\n            classList.remove(name);\r\n        } else {\r\n            classList.add(name);\r\n        }\r\n    });\r\n}"],"names":["evalInContext","ctx","expr","keepFns","listArgs","listVals","Object","keys","forEach","key","push","Function","evaluator","base","url","trim","toLowerCase","startsWith","pathJoin","editor","coreStr","async","widgetTemplate","silent","mergevars","translations","get_strings","component","userWidgetFilter","createFilterFunction","notificationManager","open","text","type","timeout","handleFilterResult","res","out","msg","setContent","filteredResult","getContent","then","catch","err","console","error","name","replace","str","def","Math","floor","RegExp","exec","val","parseInt","isNaN","ex","cb","delay","arguments","length","undefined","timeoutId","debounced","_len","args","Array","_key","window","clearTimeout","setTimeout","clear","varname","listVars","found","len","k","random","toString","substring","s","h","l","i","charCodeAt","abs","str1","needle","indexOf","transformStr","Builder","color","alpha","sep","a","split","slice","hex","alpha2","toFixed","result","r","g","b","elem","classList","_len2","classNames","_key2","contains","remove","add","Transformers","toUpperCase","txt","ytId","match","vimeoId","serveGDrive","removeHTML","escapeHTML","encodeHTML","encodeURIComponent","escapeQuotes","transSeq","constructor","parts","this","j","lenj","prts","transfunc","reduce","filterCode","endsWith","performCasting","value","parsed","parseFloat","JSON","stringify","_exports","xor","replaceStrPart","replacement","indices","getValueFromRegex","regexExpr","capturingGroupCount","bindingFactory","$e","methods","hasClass","className","query","neg","find","getValue","Boolean","setValue","bool","addClass","removeClass","notHasClass","classRegex","classExpr","castTo","ret","classes","attr","clazz","_elem$attr","cl","c","newCls","attrName","attrVal","hasAttr","attrValue","removeAttr","notHasAttr","attrRegex","_elem$attr2","oldValue","newValue","hasStyle","sty","styValue","styName","pValue","prop","getPropertyValue","css","removeProperty","style","cssText","notHasStyle","styleRegex","st","currentVal","includes","createBinding","definition","bindFn","v","get","set","capitalize"],"mappings":"6DAwCO,SAASA,cAAcC,IAAKC,KAAMC,SACrC,MAAMC,SAAW,GACXC,SAAW,GAEbJ,KACAK,OAAOC,KAAKN,KAAKO,SAASC,OAElBN,SAA+B,mBAAbF,IAAIQ,QACtBL,SAASM,KAAKD,KACdJ,SAASK,KAAKT,IAAIQ,MACtB,IAGRL,SAASM,KAAK,QACdN,SAASM,KAAK,qBACdL,SAASK,KAAKR,MAEd,OADkB,IAAIS,YAAYP,SAC3BQ,IAAaP,SACxB,+EA8TO,SAAsBQ,KAAMC,KAE/B,IADAA,KAAOA,KAAO,IAAIC,QACVC,cAAcC,WAAW,QAC7B,OAAOH,IAIX,OADYI,SAASL,KAAMC,IAE/B,oCArJO,SAAkCK,OAAQC,SAO7C,OAAOC,MAAMC,eAAgBC,OAAQC,aACjC,MAAMC,mBAAqBL,QAAQM,YAAY,CAC3C,CAACjB,IAAK,YAAakB,UAAW,kBAC9B,CAAClB,IAAK,YAAakB,UAAW,oBAG5BC,iBAAmBC,qBAAqBP,gBAE9C,IAAKM,iBAMD,OALAT,OAAOW,oBAAoBC,KAAK,CAC5BC,KAAMP,aAAa,GAAK,mBACxBQ,KAAM,SACNC,QAAS,OAEN,EAGX,MAAMC,mBAAqB,SAASC,KAChC,MAAMC,IAAMD,IAAI,GAChB,IAAIE,IAAMF,IAAI,GACH,MAAPC,IACmB,iBAARA,KACPlB,OAAOoB,WAAWF,KAClBlB,OAAOW,oBAAoBC,KAAK,CAC5BC,KAAMP,aAAa,GAAK,KAAOa,IAC/BL,KAAM,UACNC,QAAS,QAEE,IAARG,IACPlB,OAAOW,oBAAoBC,KAAK,CAC5BC,KAAMP,aAAa,GAAK,KAAOa,IAC/BL,KAAM,UACNC,QAAS,OAEE,IAARG,KAAkBd,QACzBJ,OAAOW,oBAAoBC,KAAK,CAC5BC,KAAMP,aAAa,GACnBQ,KAAM,OACNC,QAAS,MAGTX,QACRJ,OAAOW,oBAAoBC,KAAK,CAC5BC,KAAMP,aAAa,GACnBQ,KAAM,OACNC,QAAS,OAMfM,eAAiBZ,iBADHT,OAAOsB,aAC0BtB,OAAQK,WAQ7D,OANoC,MAAlBgB,gBAAsD,iBAApBA,gBAAiC,SAAUA,eAE3FA,eAAeE,KAAKP,oBAAoBQ,OAA0BC,KAAQC,QAAQC,MAAMF,OAExFT,mBAAmBK,gBAAkB,CAAC,KAAMf,aAAa,MAEtD,CAAI,CAEnB,yDA7FO,SAA4BsB,MAC/B,OAAOA,KAAKC,QAAQ,MAAO,IAC/B,sBAoGO,SAAoBC,IAAKC,KAC5B,GAAID,KAAsB,iBAARA,IACd,OAAOE,KAAKC,MAAMH,KAEtB,IAAKA,OAASA,IAAM,IAAIlC,SAAWsC,OAAO,4BAA4BC,KAAKL,IAAM,IAC7E,OAAOC,IAEX,IACI,MAAMK,IAAMC,SAASP,IAAM,IAC3B,IAAKQ,MAAMF,KACP,OAAOA,GAEf,CAAE,MAAOG,IAET,CACA,OAAOR,GACX,qGAikBO,SAAkBS,IAAkB,IAAdC,MAAKC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,IAE7BG,UAAY,KAChB,MAAMC,UAAY,WAAsC,IAAA,IAAAC,KAAAL,UAAAC,OAATK,KAAIC,IAAAA,MAAAF,MAAAG,KAAA,EAAAA,KAAAH,KAAAG,OAAJF,KAAIE,MAAAR,UAAAQ,MAC3CL,WACAM,OAAOC,aAAaP,WAExBA,UAAYM,OAAOE,YAAW,KAC5Bb,MAAMQ,KAAK,GACVP,QASP,OAPAK,UAAUQ,MAAQ,KACTT,YAGLM,OAAOC,aAAaP,WACpBA,UAAY,KAAI,EAEbC,SACX,mEA5kBO,SAA4BS,QAASC,UACxC,IAAKA,SACD,OAAO,KAEX,IAAIC,MAAQ,KACZ,MAAMC,IAAMF,SAASb,OACrB,IAAIgB,EAAI,EACR,KAAOA,EAAID,MAAQD,OACXD,SAASG,GAAG/B,OAAS2B,UACrBE,MAAQD,SAASG,IAErBA,IAEJ,OAAOF,KACX;;;;;;;;AAhUO,WACH,MAAO,IAAMzB,KAAK4B,SAASC,SAAS,IAAIC,UAAU,EACtD,oBAgCO,SAAkBC,GAErB,IAAIC,EAAI,EACR,MAAMC,GAFNF,EAAIA,GAAK,IAEGpB,OACZ,IAAIuB,EAAI,EACR,GAAID,EAAI,EACJ,KAAOC,EAAID,GACPD,GAAKA,GAAK,IAAOD,EAAEI,WAAWD,GAAK,GAAM,GACzCA,IAGR,OAAOlC,KAAKoC,IAAIJ,EACpB,gFAOO,SAAoBK,KAAMC,QAiB7B,OAhBAD,MAAQA,MAAQ,IAAIzE,OAAOC,cAC3ByE,QAAUA,QAAU,IAAI1E,OAAOC,cAC/BwE,KAAOA,KAAKxC,QAAQ,WAAY,KAC3BA,QAAQ,SAAU,KAClBA,QAAQ,SAAU,KAClBA,QAAQ,SAAU,KAClBA,QAAQ,SAAU,KAClBA,QAAQ,IAAK,KACbA,QAAQ,IAAK,IAClByC,OAASA,OAAOzC,QAAQ,WAAY,KAC/BA,QAAQ,SAAU,KAClBA,QAAQ,SAAU,KAClBA,QAAQ,SAAU,KAClBA,QAAQ,SAAU,KAClBA,QAAQ,IAAK,KACbA,QAAQ,IAAK,IACXwC,KAAKE,QAAQD,SAAW,CACnC,kBAqGO,SAAgBE,cACnB,OAAO,IAAIC,QAAQD,aACvB,2BA6nBO,SAAyBE,OAC5BA,OAASA,OAAS,WAAW9E,OAAOC,cACpC,IAAI8E,MAAQ,EACZ,GAAID,MAAM5E,WAAW,MAAyB,IAAjB4E,MAAM/B,OAE/BgC,MAAQtC,SAAS,KAAOqC,MAAMZ,UAAU,IAAM,IAC9CY,MAAQA,MAAMZ,UAAU,EAAG,QACxB,GAAIY,MAAM5E,WAAW,OAAQ,CAEhC,MAAM8E,IAAMF,MAAMH,QAAQ,MAAQ,EAAI,IAAM,IACtCM,EAAIH,MAAM7C,QAAQ,UAAW,IAAIiD,MAAMF,KAC7CF,MAAQ,MAAQ,GAAK,MAAQG,EAAE,IAAM,MAAQA,EAAE,IAAM,KAAOA,EAAE,IAAKhB,SAAS,IAAIkB,MAAM,GAErE,IAAbF,EAAElC,SACFgC,OAASE,EAAE,GACPF,MAAQ,IACRA,OAAQ,KAGpB,CACA,MAAO,CAACD,MAAOC,MACnB,kBAOO,SAAgBK,IAAKL,OACxBK,KAAOA,KAAO,WAAWpF,OAAOC,cAEhC,IAAIoF,OAASN,OAAS,EAClBM,OAAS,IACTA,QAAU,KAEC,IAAXA,QAA2B,IAAXA,SAChBA,OAASA,OAAOC,QAAQ,IAE5B,MAAMC,OAAS,2CAA2ChD,KAAK6C,KAC/D,IAAII,EAAI,EACJC,EAAI,EACJC,EAAI,EACJH,SACFC,EAAI/C,SAAS8C,OAAO,GAAI,IACxBE,EAAIhD,SAAS8C,OAAO,GAAI,IACxBG,EAAIjD,SAAS8C,OAAO,GAAI,KAE1B,GAAc,IAAVR,MACA,MAAO,OAAOS,KAAKC,KAAKC,KAE5B,MAAO,QAAQF,KAAKC,KAAKC,KAAKL,SAClC,uBAsCO,SAAqBM,MACxB,MAAMC,UAAYD,KAAKC,UAAU,IAAAC,IAAAA,MAAA/C,UAAAC,OADA+C,eAAUzC,MAAAwC,MAAAA,EAAAA,WAAAE,MAAA,EAAAA,MAAAF,MAAAE,QAAVD,WAAUC,MAAAjD,GAAAA,UAAAiD,OAE3CD,WAAWrG,SAAQuC,OACX4D,UAAUI,SAAShE,MACnB4D,UAAUK,OAAOjE,MAEjB4D,UAAUM,IAAIlE,KAClB,GAER,EAn0BA,MAAMmE,aAAe,CAEjBC,YAAa,SAASC,KAClB,OAAQA,IAAM,IAAID,aACrB,EAEDnG,YAAa,SAASoG,KAClB,OAAQA,IAAM,IAAIpG,aACrB,EAEDD,KAAM,SAASqG,KACX,OAAQA,IAAM,IAAIrG,MACrB,EAEDsG,KAAM,SAASD,KAEX,MACMb,GAAKa,KAAO,IAAIE,MADX,0GAEX,OAAIf,SAAAA,EAAGzC,OACIyC,EAAE,GAENa,GACV,EAEDG,QAAS,SAASH,KACd,MACME,MAAQ,IAAIjE,OADH,4EACkBC,KAAK8D,KAAO,IAC7C,OAAIE,aAAAA,MAAQ,GACDA,MAAM,GAEVF,GACV,EAEDI,YAAa,SAASJ,KAElB,MAAMhF,KAAOgF,IAAM,IAAIE,MAAM,0DAC7B,GAAIlF,WAAAA,IAAK0B,OAAQ,CAEb,MAAO,6CADS1B,IAAI,EAExB,CACA,OAAOgF,GACV,EAEDK,WAAY,SAASL,KACjB,OAAQA,KAAO,IAAIpE,QAAQ,aAAc,GAC5C,EAED0E,WAAY,SAASN,KACjB,OAAQA,KAAO,IAAIpE,QAAQ,KAAM,SAC5BA,QAAQ,KAAM,QACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,UACdA,QAAQ,KAAM,SACtB,EAED2E,WAAY,SAASP,KAEjB,OAAOQ,mBAAmBR,KAAO,GACpC,EAEDS,aAAc,SAAST,KACnB,OAAQA,KAAO,IAAIpE,QAAQ,MAAO,IACtC,GAIJ,MAAM4C,QACFkC,SAEAC,WAAAA,CAAYpC,cACR,MAAMqC,MAAQrC,aAAaM,MAAM,KACjCgC,KAAKH,SAAW,GAChB,IAAK,IAAII,EAAI,EAAGC,KAAOH,MAAMlE,OAAQoE,EAAIC,KAAMD,IAAK,CAChD,MAAME,KAAOJ,MAAME,GAAGnH,OAEhBsH,UAAYnB,aAAakB,MACd,MAAbC,UACAJ,KAAKH,SAASpH,KAAK2H,WAEnBxF,QAAQC,MAAM,iCAAmCsF,KAEzD,CACJ,CAGAE,MAAAA,CAAOtG,MACH,IAAK,IAAIkG,EAAI,EAAGC,KAAOF,KAAKH,SAAShE,OAAQoE,EAAIC,KAAMD,IAAK,CAExDlG,MAAOqG,EADWJ,KAAKH,SAASI,IACflG,KACrB,CACA,OAAOA,IACX,EAwBG,SAASH,qBAAqB0G,YACjC,IAAI3G,iBAAmB,KACvB,IACIA,iBAAmB,IAAIjB,SAAS,OAAQ,SAAU,OAAQ4H,WAC7D,CAAC,MAAO7E,IACL9B,iBAAmB,KACnBiB,QAAQC,MAAMY,GAClB,CACA,OAAO9B,gBACX,CAkIO,SAASV,SAAS8E,EAAGS,GASxB,OARAT,GAAKA,GAAK,IAAIjF,OACd0F,GAAKA,GAAK,IAAI1F,OACTiF,EAAEwC,SAAS,OACZxC,GAAQ,KAERS,EAAExF,WAAW,OACbwF,EAAIA,EAAExB,UAAU,IAEbe,EAAIS,CACf,CAuBO,MAAMgC,eAAiB,SAASC,MAAOzG,MAC1C,IAAKA,aAAeyG,QAAUzG,KAC1B,OAAOyG,MAEX,OAAQzG,MACJ,IAAM,UAEEyG,MADU,IAAVA,OAAyB,MAAVA,QAA2B,IAAVA,OAA4B,SAAVA,MAKtD,MACJ,IAAM,SACF,IACI,IAAIC,OAEAA,QADCD,MAAQ,IAAIhD,QAAQ,KAAO,EACnBlC,SAASkF,OAETE,WAAWF,OAEnBjF,MAAMkF,SAGPD,MAAQ,EACR7F,QAAQC,MAAM,wBAAwB4F,UAHtCA,MAAQC,MAKf,CAAC,MAAOjF,IACLgF,MAAQ,EACR7F,QAAQC,MAAM,wBAAwB4F,QAC1C,CACA,MACJ,IAAM,SACmB,iBAAVA,MACPA,MAAQG,KAAKC,UAAUJ,OAEvBA,OAAgB,GAEpB,MACJ,QACI7F,QAAQC,MAAM,gBAAgB4F,YAAYzG,QAElD,OAAOyG,OACTK,SAAAN,eAAAA,eAMF,MAAMO,IAAM,SAAShD,EAAGS,GACpB,OAAQT,IAAOS,GASbwC,eAAiB,SAAShG,IAAKqE,MAAO4B,aACxC,IAAK5B,MAAM6B,QAEP,OADAtG,QAAQC,MAAM,yCACPG,IAEX,MAAO+C,EAAGS,GAAKa,MAAM6B,QAAQ,GAC7B,OAAOlG,IAAIgC,UAAU,EAAGe,GAAKkD,YAAcjG,IAAIgC,UAAUwB,IAUvD2C,kBAAoB,SAASC,UAAWH,aAE1C,IAAII,oBAAsB,EAC1B,OAAOD,UAAUrG,QAFA,mBAEkB,KAC/BsG,sBAC4B,IAAxBA,oBACOJ,YAAc,GAElB,OAQTK,eAAiB,SAASC,IAE5B,MAAMC,QAAU,CAOZC,SAAUA,CAACC,UAAWC,MAAOC,OAEzB,IAAInD,KAAO8C,GAIX,OAHII,QACAlD,KAAO8C,GAAGM,KAAKF,QAEZ,CAEHG,SAAUA,KACN,MAAM3H,IAAM4G,IAAIa,IAAKnD,KAAKgD,SAASC,YACnC,OAAOK,QAAQ5H,IAAI,EAGvB6H,SAAWC,OACHlB,IAAIa,IAAKK,MACTxD,KAAKyD,SAASR,WAEdjD,KAAK0D,YAAYT,UACrB,EAEP,EAOLU,YAAaA,CAACV,UAAWC,QACdH,QAAQC,SAASC,UAAWC,OAAO,GAQ9CU,WAAYA,CAACC,UAAWX,MAAOY,UAC3B,IAAI9D,KAAO8C,GAIX,OAHII,QACAlD,KAAO8C,GAAGM,KAAKF,QAEZ,CACHG,SAAUA,KACN,IAAIU,IAAM,GACV,MAAMC,SAAWhE,KAAKiE,KAAK,UAAY,IAAI1E,MAAM,KACjD,IAAK,MAAM2E,SAASF,QAAS,CACzB,MAAMpD,MAAQ,IAAIjE,OAAOkH,WAAWjH,KAAKsH,OACzC,GAAItD,aAAAA,MAAQ,IAA4B,iBAAdA,MAAM,GAAkB,CAC9CmD,IAAMnD,MAAM,GACZ,KACJ,CACJ,CACA,OAAOmB,eAAegC,IAAKD,OAAO,EAEtCP,SAAW1G,MAAQ,IAAAsH,WACf,MAAMC,IAAuBD,QAAlBA,WAAAnE,KAAKiE,KAAK,oBAAQE,kBAAlBA,WAAoB5E,MAAM,SAAU,GAC/C,IAAIrB,OAAQ,EAaZ,GAZAkG,GAAGtK,SAAQuK,IACP,MAAMzD,MAAQ,IAAIjE,OAAOkH,UAAW,KAAKjH,KAAKyH,GAC9C,GAAc,OAAVzD,MACA,OAEJ1C,OAAQ,EACR8B,KAAK0D,YAAYW,GACjB,MAAMC,OAAS/B,eAAe8B,EAAGzD,MAAO/D,IAAM,IAC9CmD,KAAKyD,SAASa,OAAO,KAIpBpG,MAAO,CACR,MAAMoG,OAAS5B,kBAAkBmB,UAAWhH,IAAM,IAClDmD,KAAKyD,SAASa,OAClB,GAEP,EAQLL,KAAMA,CAACM,SAAUrB,MAAOY,UACpB,IAAI9D,KAAO8C,GAIX,OAHII,QACAlD,KAAO8C,GAAGM,KAAKF,QAEZ,CACHG,SAAUA,IACCtB,eAAe/B,KAAKiE,KAAKM,UAAWT,QAG/CP,SAAW1G,MACY,kBAARA,MACPA,IAAMA,IAAM,EAAI,GAEpB,MAAM2H,QAAU3H,IAAM,GACtBmD,KAAKiE,KAAKM,SAAUC,SACH,SAAbD,UAAoC,QAAbA,UACvBvE,KAAKiE,KAAK,YAAcM,SAAUC,QACtC,EAEP,EAQLC,QAASA,CAACR,KAAMf,MAAOC,OACnB,IAAInD,KAAO8C,GACPI,QACAlD,KAAO8C,GAAGM,KAAKF,QAEnB,MAAM5B,MAAQ2C,KAAK1E,MAAM,KACnBgF,SAAWjD,MAAM,GAAGjH,OAC1B,IAAIqK,UAAY,GAIhB,OAHIpD,MAAMlE,OAAS,IACfsH,UAAYpD,MAAM,GAAGjH,QAElB,CACHgJ,SAAUA,KACN,IAAInF,MAA+B,MAAvB8B,KAAKiE,KAAKM,UAItB,OAHIG,YACAxG,MAAQA,OAAS8B,KAAKiE,KAAKM,YAAcG,WAEtCpC,IAAIa,IAAKjF,MAAM,EAG1BqF,SAAWC,OACHlB,IAAIa,IAAKK,OACTxD,KAAKiE,KAAKM,SAAUG,WAAa,IAChB,SAAbH,UAAoC,QAAbA,UACvBvE,KAAKiE,KAAK,YAAcM,SAAUG,UAAY,MAGlD1E,KAAK2E,WAAWJ,UACC,SAAbA,UAAoC,QAAbA,UACvBvE,KAAK2E,WAAW,YAAcJ,UAEtC,EAEP,EAOLK,WAAYA,CAACX,KAAMf,QACRH,QAAQ0B,QAAQR,KAAMf,OAAO,GAQxC2B,UAAW,SAASZ,KAAMf,MAAOY,QAC7B,IAAI9D,KAAO8C,GACPI,QACAlD,KAAO8C,GAAGM,KAAKF,QAEnB,MAAM5B,MAAQ2C,KAAK1E,MAAM,KACnBgF,SAAWjD,MAAM,GAAGjH,OAC1B,IAAIqK,UAAY,GAIhB,OAHIpD,MAAMlE,OAAS,IACfsH,UAAYpD,MAAM,GAAGjH,QAElB,CACHgJ,QAAAA,GAEI,GADqC,MAAvBrD,KAAKiE,KAAKM,UACb,CAAA,IAAAO,YACP,MAAMlE,MAA2B,QAAtBkE,YAAG9E,KAAKiE,KAAKM,iBAAVO,IAAmBA,iBAAnBA,EAAAA,YAAqBlE,MAAM8D,WACzC,OAAI9D,aAAAA,MAAQ,IAA4B,iBAAdA,MAAM,GACrBmB,eAAenB,MAAM,GAAIkD,QAE7B,EACX,CACA,OAAO,IACV,EACDP,QAAAA,CAAS1G,KACL,MAAMkI,SAAW/E,KAAKiE,KAAKM,WAAa,GAClC3D,MAAQ,IAAIjE,OAAO+H,UAAW,KAAK9H,KAAKmI,UAC9C,IAAIC,SAEAA,SADApE,MACW2B,eAAewC,SAAUnE,MAAO/D,IAAM,IAEtC6F,kBAAkBgC,UAAW7H,IAAM,IAElDmD,KAAKiE,KAAKM,SAAUS,UACH,SAAbT,UAAoC,QAAbA,UACvBvE,KAAKiE,KAAK,YAAcM,SAAUS,SAAW,GAErD,EAEP,EAODC,SAAU,SAASC,IAAKhC,MAAOC,KAC3B,IAAInD,KAAO8C,GACPI,QACAlD,KAAO8C,GAAGM,KAAKF,QAEnB,MAAM5B,MAAQ4D,IAAI3F,MAAM,KACxB,IAEI4F,SAFAC,QAAU9D,MAAM,GAAGjH,OAMvB,OAHIiH,MAAMlE,OAAS,IACf+H,SAAW7D,MAAM,GAAGjH,QAEjB,CACHgJ,QAAAA,GACI,MACMgC,OADKrF,KAAKsF,KAAK,SACHC,iBAAiBH,SAEnC,OAAO9C,SADkBjF,IAAb8H,SAAoC,KAAXE,OAAgBA,SAAWF,SAChDhC,IACnB,EAEDI,QAAAA,CAASC,MACL,GAAIlB,IAAIkB,KAAML,KACVnD,KAAKwF,IAAIJ,QAASD,UAAY,QAC3B,CACQnF,KAAKsF,KAAK,SAClBG,eAAeL,QACtB,CAEApF,KAAKiE,KAAK,iBAAkBjE,KAAK,GAAG0F,MAAMC,QAC9C,EAEP,EAMDC,YAAaA,CAACV,IAAKhC,QACRH,QAAQkC,SAASC,IAAKhC,OAAO,GAQxC2C,WAAY,SAAS5B,KAAMf,MAAOY,QAC9B,IAAI9D,KAAO8C,GACPI,QACAlD,KAAO8C,GAAGM,KAAKF,QAEnB,MAAM5B,MAAQ2C,KAAK1E,MAAM,KACnB6F,QAAU9D,MAAM,GAAGjH,OACzB,IAAI8K,SAAW,GAIf,OAHI7D,MAAMlE,OAAS,IACf+H,SAAW7D,MAAM,GAAGjH,QAEjB,CAEHgJ,QAAAA,GACI,MAAMyC,GAAK9F,KAAKsF,KAAK,SACfS,WAAaD,cAAAA,EAAAA,GAAIP,iBAAiBH,SACxC,GAAIW,WAAY,CACZ,IAAIZ,SAMA,OAAOpD,eAAegE,WAAYjC,QANxB,CACV,MAAMlD,MAAQ,IAAIjE,OAAOwI,UAAUvI,KAAKmJ,YACxC,GAAInF,aAAAA,MAAQ,IAA4B,iBAAdA,MAAM,GAC5B,OAAOmB,eAAenB,MAAM,GAAIkD,OAExC,CAGJ,CACA,OAAO/B,eAAe,GAAI+B,OAC7B,EAEDP,QAAAA,CAAS1G,KACL,IAAImI,SACJ,GAAIG,SAEA,IAAKC,QAAQY,SAAS,UAAYZ,QAAQY,SAAS,YAAe9D,WAAWrF,IAAM,KAAO,EACtFmI,SAAW,OACR,CACH,MAAMD,SAAW/E,KAAKsF,KAAK,SAASC,iBAAiBH,UAAY,GACjE,GAAIL,SAAU,CACV,MAAMnE,MAAQ,IAAIjE,OAAOwI,SAAU,KAAKvI,KAAKmI,UAE7CC,SAAWzC,eAAewC,SAAUnE,MAAO/D,IAAM,GACrD,MACImI,SAAWG,SAAS7I,QAAQ,OAAQO,IAAM,GAElD,MAEAmI,SAAWnI,IAAM,GAErBmD,KAAKwF,IAAIJ,QAASJ,UAElBhF,KAAKiE,KAAK,iBAAkBjE,KAAK,GAAG0F,MAAMC,QAC9C,EAER,GAEJ,OAAO5C,SAiCTV,SAAA4D,cAnB2BA,CAACC,WAAYlG,KAAM8D,UAE5C,IAAIqC,OAAS,KACb,MAA4B,iBAAhBD,WACD5M,cAAc,IAAIuJ,eAAe7C,OAAQkG,YAAY,IAG5DC,OAAS,CACL9C,SAAUA,KACN,IAAI+C,EAAI9M,cAAc,CAAC0G,WAAO,IAAIkG,WAAWG,cAI7C,OAHIvC,SACAsC,EAAIrE,eAAeqE,EAAGtC,SAEnBsC,CAAC,EAEZ7C,SAAW6C,GAAM9M,cAAc,CAAC0G,UAAMoG,KAAI,IAAIF,WAAWI,kBAG1DH,OAAM,EAQ2D9D,SAAAkE,WAAlD/H,GAAMA,GAAKA,EAAE,GAAGiC,cAAgBjC,EAAEgB,MAAM,IAAO,EAwGxE"}