{"version":3,"file":"js_yaml-lazy.min.js","sources":["../../src/libs/js_yaml-lazy.js"],"sourcesContent":["// @ts-nocheck\r\n/* eslint-disable */\r\n// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Tiny WidgetHub plugin.\r\n *\r\n * @module      tiny_widgethub/plugin\r\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\r\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\n/* ! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */\r\n/**\r\n *\r\n * @param {*} subject\r\n */\r\nfunction isNothing(subject) {\r\n    return (typeof subject === 'undefined') || (subject === null);\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {*} subject\r\n */\r\nfunction isObject(subject) {\r\n    return (typeof subject === 'object') && (subject !== null);\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {*} sequence\r\n */\r\nfunction toArray(sequence) {\r\n    if (Array.isArray(sequence)) {\r\n        return sequence;\r\n    } else if (isNothing(sequence)) {\r\n        return [];\r\n    }\r\n\r\n    return [sequence];\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {*} target\r\n * @param {*} source\r\n */\r\nfunction extend(target, source) {\r\n    let index, length, key, sourceKeys;\r\n\r\n    if (source) {\r\n        sourceKeys = Object.keys(source);\r\n\r\n        for (index = 0, length = sourceKeys.length; index < length; index += 1) {\r\n            key = sourceKeys[index];\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n\r\n    return target;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {string} string\r\n * @param {number} count\r\n */\r\nfunction repeat(string, count) {\r\n    let result = '',\r\n        cycle;\r\n\r\n    for (cycle = 0; cycle < count; cycle += 1) {\r\n        result += string;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {number} number\r\n */\r\nfunction isNegativeZero(number) {\r\n    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\r\n}\r\n\r\n\r\nlet isNothing_1 = isNothing;\r\nlet isObject_1 = isObject;\r\nlet toArray_1 = toArray;\r\nlet repeat_1 = repeat;\r\nlet isNegativeZero_1 = isNegativeZero;\r\nlet extend_1 = extend;\r\n\r\nlet common = {\r\n    isNothing: isNothing_1,\r\n    isObject: isObject_1,\r\n    toArray: toArray_1,\r\n    repeat: repeat_1,\r\n    isNegativeZero: isNegativeZero_1,\r\n    extend: extend_1\r\n};\r\n\r\n// YAML error class. http://stackoverflow.com/questions/8458984\r\n\r\n\r\n/**\r\n *\r\n * @param {*} exception\r\n * @param {*} compact\r\n */\r\nfunction formatError(exception, compact) {\r\n    let where = '',\r\n        message = exception.reason || '(unknown reason)';\r\n\r\n    if (!exception.mark) {\r\n        return message;\r\n    }\r\n\r\n    if (exception.mark.name) {\r\n        where += 'in \"' + exception.mark.name + '\" ';\r\n    }\r\n\r\n    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\r\n\r\n    if (!compact && exception.mark.widget) {\r\n        where += '\\n\\n' + exception.mark.widget;\r\n    }\r\n\r\n    return message + ' ' + where;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {string} reason\r\n * @param {*} [mark]\r\n */\r\nfunction YAMLException$1(reason, mark) {\r\n    // Super constructor\r\n    Error.call(this);\r\n\r\n    this.name = 'YAMLException';\r\n    this.reason = reason;\r\n    this.mark = mark;\r\n    this.message = formatError(this, false);\r\n\r\n    // Include stack trace in error object\r\n    if (Error.captureStackTrace) {\r\n        // Chrome and NodeJS\r\n        Error.captureStackTrace(this, this.constructor);\r\n    } else {\r\n        // FF, IE 10+ and Safari 6+. Fallback for others\r\n        this.stack = (new Error()).stack || '';\r\n    }\r\n}\r\n\r\n\r\n// Inherit from Error\r\nYAMLException$1.prototype = Object.create(Error.prototype);\r\nYAMLException$1.prototype.constructor = YAMLException$1;\r\n\r\n/** @param {*} compact */\r\nYAMLException$1.prototype.toString = function toString(compact) {\r\n    return this.name + ': ' + formatError(this, compact);\r\n};\r\n\r\n\r\nlet exception = YAMLException$1;\r\n\r\n// Get widget for a single line, respecting maxLength\r\n/**\r\n *\r\n * @param {*} buffer\r\n * @param {number} lineStart\r\n * @param {number} lineEnd\r\n * @param {number} position\r\n * @param {number} maxLineLength\r\n */\r\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\r\n    let head = '';\r\n    let tail = '';\r\n    let maxHalfLength = Math.floor(maxLineLength / 2) - 1;\r\n\r\n    if (position - lineStart > maxHalfLength) {\r\n        head = ' ... ';\r\n        lineStart = position - maxHalfLength + head.length;\r\n    }\r\n\r\n    if (lineEnd - position > maxHalfLength) {\r\n        tail = ' ...';\r\n        lineEnd = position + maxHalfLength - tail.length;\r\n    }\r\n\r\n    return {\r\n        str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '→') + tail,\r\n        pos: position - lineStart + head.length // Relative position\r\n    };\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {string} string\r\n * @param {number} max\r\n */\r\nfunction padStart(string, max) {\r\n    return common.repeat(' ', max - string.length) + string;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {*} mark\r\n * @param {*} options\r\n */\r\nfunction makeWidget(mark, options) {\r\n    options = Object.create(options || null);\r\n\r\n    if (!mark.buffer) {\r\n        return null;\r\n    }\r\n\r\n    if (!options.maxLength) {\r\n        options.maxLength = 79;\r\n    }\r\n    if (typeof options.indent !== 'number') {\r\n        options.indent = 1;\r\n    }\r\n    if (typeof options.linesBefore !== 'number') {\r\n        options.linesBefore = 3;\r\n    }\r\n    if (typeof options.linesAfter !== 'number') {\r\n        options.linesAfter = 2;\r\n    }\r\n\r\n    let re = /\\r?\\n|\\r|\\0/g;\r\n    let lineStarts = [0];\r\n    let lineEnds = [];\r\n    let match;\r\n    let foundLineNo = -1;\r\n\r\n    while ((match = re.exec(mark.buffer))) {\r\n        lineEnds.push(match.index);\r\n        lineStarts.push(match.index + match[0].length);\r\n\r\n        if (mark.position <= match.index && foundLineNo < 0) {\r\n            foundLineNo = lineStarts.length - 2;\r\n        }\r\n    }\r\n\r\n    if (foundLineNo < 0) {\r\n        foundLineNo = lineStarts.length - 1;\r\n    }\r\n\r\n    let result = '',\r\n        i, line;\r\n    let lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\r\n    let maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\r\n\r\n    for (i = 1; i <= options.linesBefore; i++) {\r\n        if (foundLineNo - i < 0) {\r\n            break;\r\n        }\r\n        line = getLine(\r\n            mark.buffer,\r\n            lineStarts[foundLineNo - i],\r\n            lineEnds[foundLineNo - i],\r\n            mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\r\n            maxLineLength\r\n        );\r\n        result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\r\n            ' | ' + line.str + '\\n' + result;\r\n    }\r\n\r\n    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\r\n    result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\r\n        ' | ' + line.str + '\\n';\r\n    result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\r\n\r\n    for (i = 1; i <= options.linesAfter; i++) {\r\n        if (foundLineNo + i >= lineEnds.length) {\r\n            break;\r\n        }\r\n        line = getLine(\r\n            mark.buffer,\r\n            lineStarts[foundLineNo + i],\r\n            lineEnds[foundLineNo + i],\r\n            mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\r\n            maxLineLength\r\n        );\r\n        result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\r\n            ' | ' + line.str + '\\n';\r\n    }\r\n\r\n    return result.replace(/\\n$/, '');\r\n}\r\n\r\n\r\nlet widget = makeWidget;\r\n\r\nlet TYPE_CONSTRUCTOR_OPTIONS = [\r\n    'kind',\r\n    'multi',\r\n    'resolve',\r\n    'construct',\r\n    'instanceOf',\r\n    'predicate',\r\n    'represent',\r\n    'representName',\r\n    'defaultStyle',\r\n    'styleAliases'\r\n];\r\n\r\nlet YAML_NODE_KINDS = [\r\n    'scalar',\r\n    'sequence',\r\n    'mapping'\r\n];\r\n\r\n/**\r\n *\r\n * @param {*} map\r\n * @returns {Object.<string, *>}\r\n */\r\nfunction compileStyleAliases(map) {\r\n    /** @type {Object.<string, *>} */\r\n    let result = {};\r\n\r\n    if (map !== null) {\r\n        Object.keys(map).forEach(function(style) {\r\n            map[style].forEach(\r\n                /** @param {*} alias */\r\n                function(alias) {\r\n                    result[String(alias)] = style;\r\n                });\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} tag\r\n * @param {*} options\r\n */\r\nfunction Type$1(tag, options) {\r\n    options = options || {};\r\n\r\n    Object.keys(options).forEach(function(name) {\r\n        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\r\n            throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\r\n        }\r\n    });\r\n\r\n    // TODO: Add tag format check.\r\n    this.options = options; // Keep original options in case user wants to extend this type later\r\n    this.tag = tag;\r\n    this.kind = options.kind || null;\r\n    this.resolve = options.resolve || function() {\r\n        return true;\r\n    };\r\n    this.construct = options.construct || function(data) {\r\n        return data;\r\n    };\r\n    this.instanceOf = options.instanceOf || null;\r\n    this.predicate = options.predicate || null;\r\n    this.represent = options.represent || null;\r\n    this.representName = options.representName || null;\r\n    this.defaultStyle = options.defaultStyle || null;\r\n    this.multi = options.multi || false;\r\n    this.styleAliases = compileStyleAliases(options.styleAliases || null);\r\n\r\n    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\r\n        throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\r\n    }\r\n}\r\n\r\nlet type = Type$1;\r\n\r\n/* eslint-disable max-len*/\r\n\r\n\r\n/**\r\n *\r\n * @param schema\r\n * @param name\r\n */\r\nfunction compileList(schema, name) {\r\n    let result = [];\r\n\r\n    schema[name].forEach(function(currentType) {\r\n        let newIndex = result.length;\r\n\r\n        result.forEach(function(previousType, previousIndex) {\r\n            if (previousType.tag === currentType.tag &&\r\n                previousType.kind === currentType.kind &&\r\n                previousType.multi === currentType.multi) {\r\n\r\n                newIndex = previousIndex;\r\n            }\r\n        });\r\n\r\n        result[newIndex] = currentType;\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\n\r\n/**\r\n *\r\n */\r\nfunction compileMap(/* Lists... */) {\r\n    let result = {\r\n        scalar: {},\r\n        sequence: {},\r\n        mapping: {},\r\n        fallback: {},\r\n        multi: {\r\n            scalar: [],\r\n            sequence: [],\r\n            mapping: [],\r\n            fallback: []\r\n        }\r\n    },\r\n        index, length;\r\n\r\n    /**\r\n     *\r\n     * @param type\r\n     */\r\n    function collectType(type) {\r\n        if (type.multi) {\r\n            result.multi[type.kind].push(type);\r\n            result.multi.fallback.push(type);\r\n        } else {\r\n            result[type.kind][type.tag] = result.fallback[type.tag] = type;\r\n        }\r\n    }\r\n\r\n    for (index = 0, length = arguments.length; index < length; index += 1) {\r\n        arguments[index].forEach(collectType);\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param definition\r\n */\r\nfunction Schema$1(definition) {\r\n    return this.extend(definition);\r\n}\r\n\r\n\r\nSchema$1.prototype.extend = function extend(definition) {\r\n    let implicit = [];\r\n    let explicit = [];\r\n\r\n    if (definition instanceof type) {\r\n        // Schema.extend(type)\r\n        explicit.push(definition);\r\n\r\n    } else if (Array.isArray(definition)) {\r\n        // Schema.extend([ type1, type2, ... ])\r\n        explicit = explicit.concat(definition);\r\n\r\n    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\r\n        // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\r\n        if (definition.implicit) {\r\n            implicit = implicit.concat(definition.implicit);\r\n        }\r\n        if (definition.explicit) {\r\n            explicit = explicit.concat(definition.explicit);\r\n        }\r\n\r\n    } else {\r\n        throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\r\n            'or a schema definition ({ implicit: [...], explicit: [...] })');\r\n    }\r\n\r\n    implicit.forEach(function(type$1) {\r\n        if (!(type$1 instanceof type)) {\r\n            throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\r\n        }\r\n\r\n        if (type$1.loadKind && type$1.loadKind !== 'scalar') {\r\n            throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\r\n        }\r\n\r\n        if (type$1.multi) {\r\n            throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\r\n        }\r\n    });\r\n\r\n    explicit.forEach(function(type$1) {\r\n        if (!(type$1 instanceof type)) {\r\n            throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\r\n        }\r\n    });\r\n\r\n    let result = Object.create(Schema$1.prototype);\r\n\r\n    result.implicit = (this.implicit || []).concat(implicit);\r\n    result.explicit = (this.explicit || []).concat(explicit);\r\n\r\n    result.compiledImplicit = compileList(result, 'implicit');\r\n    result.compiledExplicit = compileList(result, 'explicit');\r\n    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);\r\n\r\n    return result;\r\n};\r\n\r\n\r\nlet schema = Schema$1;\r\n\r\nlet str = new type('tag:yaml.org,2002:str', {\r\n    kind: 'scalar',\r\n    construct: function(data) {\r\n        return data !== null ? data : '';\r\n    }\r\n});\r\n\r\nlet seq = new type('tag:yaml.org,2002:seq', {\r\n    kind: 'sequence',\r\n    construct: function(data) {\r\n        return data !== null ? data : [];\r\n    }\r\n});\r\n\r\nlet map = new type('tag:yaml.org,2002:map', {\r\n    kind: 'mapping',\r\n    construct: function(data) {\r\n        return data !== null ? data : {};\r\n    }\r\n});\r\n\r\nlet failsafe = new schema({\r\n    explicit: [\r\n        str,\r\n        seq,\r\n        map\r\n    ]\r\n});\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlNull(data) {\r\n    if (data === null) {\r\n        return true;\r\n    }\r\n\r\n    let max = data.length;\r\n\r\n    return (max === 1 && data === '~') ||\r\n        (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction constructYamlNull() {\r\n    return null;\r\n}\r\n\r\n/**\r\n *\r\n * @param object\r\n */\r\nfunction isNull(object) {\r\n    return object === null;\r\n}\r\n\r\nlet _null = new type('tag:yaml.org,2002:null', {\r\n    kind: 'scalar',\r\n    resolve: resolveYamlNull,\r\n    construct: constructYamlNull,\r\n    predicate: isNull,\r\n    represent: {\r\n        canonical: function() {\r\n            return '~';\r\n        },\r\n        lowercase: function() {\r\n            return 'null';\r\n        },\r\n        uppercase: function() {\r\n            return 'NULL';\r\n        },\r\n        camelcase: function() {\r\n            return 'Null';\r\n        },\r\n        empty: function() {\r\n            return '';\r\n        }\r\n    },\r\n    defaultStyle: 'lowercase'\r\n});\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlBoolean(data) {\r\n    if (data === null) {\r\n        return false;\r\n    }\r\n\r\n    let max = data.length;\r\n\r\n    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\r\n        (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction constructYamlBoolean(data) {\r\n    return data === 'true' ||\r\n        data === 'True' ||\r\n        data === 'TRUE';\r\n}\r\n\r\n/**\r\n *\r\n * @param object\r\n */\r\nfunction isBoolean(object) {\r\n    return Object.prototype.toString.call(object) === '[object Boolean]';\r\n}\r\n\r\nlet bool = new type('tag:yaml.org,2002:bool', {\r\n    kind: 'scalar',\r\n    resolve: resolveYamlBoolean,\r\n    construct: constructYamlBoolean,\r\n    predicate: isBoolean,\r\n    represent: {\r\n        lowercase: function(object) {\r\n            return object ? 'true' : 'false';\r\n        },\r\n        uppercase: function(object) {\r\n            return object ? 'TRUE' : 'FALSE';\r\n        },\r\n        camelcase: function(object) {\r\n            return object ? 'True' : 'False';\r\n        }\r\n    },\r\n    defaultStyle: 'lowercase'\r\n});\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction isHexCode(c) {\r\n    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\r\n        ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\r\n        ((0x61/* A */ <= c) && (c <= 0x66/* F */));\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction isOctCode(c) {\r\n    return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction isDecCode(c) {\r\n    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlInteger(data) {\r\n    if (data === null) {\r\n        return false;\r\n    }\r\n\r\n    let max = data.length,\r\n        index = 0,\r\n        hasDigits = false,\r\n        ch;\r\n\r\n    if (!max) {\r\n        return false;\r\n    }\r\n\r\n    ch = data[index];\r\n\r\n    // Sign\r\n    if (ch === '-' || ch === '+') {\r\n        ch = data[++index];\r\n    }\r\n\r\n    if (ch === '0') {\r\n        // 0\r\n        if (index + 1 === max) {\r\n            return true;\r\n        }\r\n        ch = data[++index];\r\n\r\n        // Base 2, base 8, base 16\r\n\r\n        if (ch === 'b') {\r\n            // Base 2\r\n            index++;\r\n\r\n            for (; index < max; index++) {\r\n                ch = data[index];\r\n                if (ch === '_') {\r\n                    continue;\r\n                }\r\n                if (ch !== '0' && ch !== '1') {\r\n                    return false;\r\n                }\r\n                hasDigits = true;\r\n            }\r\n            return hasDigits && ch !== '_';\r\n        }\r\n\r\n\r\n        if (ch === 'x') {\r\n            // Base 16\r\n            index++;\r\n\r\n            for (; index < max; index++) {\r\n                ch = data[index];\r\n                if (ch === '_') {\r\n                    continue;\r\n                }\r\n                if (!isHexCode(data.charCodeAt(index))) {\r\n                    return false;\r\n                }\r\n                hasDigits = true;\r\n            }\r\n            return hasDigits && ch !== '_';\r\n        }\r\n\r\n\r\n        if (ch === 'o') {\r\n            // Base 8\r\n            index++;\r\n\r\n            for (; index < max; index++) {\r\n                ch = data[index];\r\n                if (ch === '_') {\r\n                    continue;\r\n                }\r\n                if (!isOctCode(data.charCodeAt(index))) {\r\n                    return false;\r\n                }\r\n                hasDigits = true;\r\n            }\r\n            return hasDigits && ch !== '_';\r\n        }\r\n    }\r\n\r\n    // Base 10 (except 0)\r\n\r\n    // value should not start with `_`;\r\n    if (ch === '_') {\r\n        return false;\r\n    }\r\n\r\n    for (; index < max; index++) {\r\n        ch = data[index];\r\n        if (ch === '_') {\r\n            continue;\r\n        }\r\n        if (!isDecCode(data.charCodeAt(index))) {\r\n            return false;\r\n        }\r\n        hasDigits = true;\r\n    }\r\n\r\n    // Should have digits and should not end with `_`\r\n    if (!hasDigits || ch === '_') {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction constructYamlInteger(data) {\r\n    let value = data,\r\n        sign = 1,\r\n        ch;\r\n\r\n    if (value.indexOf('_') !== -1) {\r\n        value = value.replace(/_/g, '');\r\n    }\r\n\r\n    ch = value[0];\r\n\r\n    if (ch === '-' || ch === '+') {\r\n        if (ch === '-') {\r\n            sign = -1;\r\n        }\r\n        value = value.slice(1);\r\n        ch = value[0];\r\n    }\r\n\r\n    if (value === '0') {\r\n        return 0;\r\n    }\r\n\r\n    if (ch === '0') {\r\n        if (value[1] === 'b') {\r\n            return sign * parseInt(value.slice(2), 2);\r\n        }\r\n        if (value[1] === 'x') {\r\n            return sign * parseInt(value.slice(2), 16);\r\n        }\r\n        if (value[1] === 'o') {\r\n            return sign * parseInt(value.slice(2), 8);\r\n        }\r\n    }\r\n\r\n    return sign * parseInt(value, 10);\r\n}\r\n\r\n/**\r\n *\r\n * @param object\r\n */\r\nfunction isInteger(object) {\r\n    return (Object.prototype.toString.call(object)) === '[object Number]' &&\r\n        (object % 1 === 0 && !common.isNegativeZero(object));\r\n}\r\n\r\nlet int = new type('tag:yaml.org,2002:int', {\r\n    kind: 'scalar',\r\n    resolve: resolveYamlInteger,\r\n    construct: constructYamlInteger,\r\n    predicate: isInteger,\r\n    represent: {\r\n        binary: function(obj) {\r\n            return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\r\n        },\r\n        octal: function(obj) {\r\n            return obj >= 0 ? '0o' + obj.toString(8) : '-0o' + obj.toString(8).slice(1);\r\n        },\r\n        decimal: function(obj) {\r\n            return obj.toString(10);\r\n        },\r\n\r\n        hexadecimal: function(obj) {\r\n            return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\r\n        }\r\n    },\r\n    defaultStyle: 'decimal',\r\n    styleAliases: {\r\n        binary: [2, 'bin'],\r\n        octal: [8, 'oct'],\r\n        decimal: [10, 'dec'],\r\n        hexadecimal: [16, 'hex']\r\n    }\r\n});\r\n\r\nlet YAML_FLOAT_PATTERN = new RegExp(\r\n    // 2.5e4, 2.5 and integers\r\n    '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\r\n    // .2e4, .2\r\n    // special case, seems not from spec\r\n    '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\r\n    // .inf\r\n    '|[-+]?\\\\.(?:inf|Inf|INF)' +\r\n    // .nan\r\n    '|\\\\.(?:nan|NaN|NAN))$');\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlFloat(data) {\r\n    if (data === null) {\r\n        return false;\r\n    }\r\n\r\n    if (!YAML_FLOAT_PATTERN.test(data) ||\r\n        // Quick hack to not allow integers end with `_`\r\n        // Probably should update regexp & check speed\r\n        data[data.length - 1] === '_') {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction constructYamlFloat(data) {\r\n    let value, sign;\r\n\r\n    value = data.replace(/_/g, '').toLowerCase();\r\n    sign = value[0] === '-' ? -1 : 1;\r\n\r\n    if ('+-'.indexOf(value[0]) >= 0) {\r\n        value = value.slice(1);\r\n    }\r\n\r\n    if (value === '.inf') {\r\n        return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\r\n\r\n    } else if (value === '.nan') {\r\n        return NaN;\r\n    }\r\n    return sign * parseFloat(value, 10);\r\n}\r\n\r\n\r\nlet SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\r\n\r\n/**\r\n *\r\n * @param object\r\n * @param style\r\n */\r\nfunction representYamlFloat(object, style) {\r\n    let res;\r\n\r\n    if (isNaN(object)) {\r\n        switch (style) {\r\n            case 'lowercase': return '.nan';\r\n            case 'uppercase': return '.NAN';\r\n            case 'camelcase': return '.NaN';\r\n        }\r\n    } else if (Number.POSITIVE_INFINITY === object) {\r\n        switch (style) {\r\n            case 'lowercase': return '.inf';\r\n            case 'uppercase': return '.INF';\r\n            case 'camelcase': return '.Inf';\r\n        }\r\n    } else if (Number.NEGATIVE_INFINITY === object) {\r\n        switch (style) {\r\n            case 'lowercase': return '-.inf';\r\n            case 'uppercase': return '-.INF';\r\n            case 'camelcase': return '-.Inf';\r\n        }\r\n    } else if (common.isNegativeZero(object)) {\r\n        return '-0.0';\r\n    }\r\n\r\n    res = object.toString(10);\r\n\r\n    // JS stringifier can build scientific format without dots: 5e-100,\r\n    // while YAML requres dot: 5.e-100. Fix it with simple hack\r\n\r\n    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\r\n}\r\n\r\n/**\r\n *\r\n * @param object\r\n */\r\nfunction isFloat(object) {\r\n    return (Object.prototype.toString.call(object) === '[object Number]') &&\r\n        (object % 1 !== 0 || common.isNegativeZero(object));\r\n}\r\n\r\nlet float = new type('tag:yaml.org,2002:float', {\r\n    kind: 'scalar',\r\n    resolve: resolveYamlFloat,\r\n    construct: constructYamlFloat,\r\n    predicate: isFloat,\r\n    represent: representYamlFloat,\r\n    defaultStyle: 'lowercase'\r\n});\r\n\r\nlet json = failsafe.extend({\r\n    implicit: [\r\n        _null,\r\n        bool,\r\n        int,\r\n        float\r\n    ]\r\n});\r\n\r\nlet core = json;\r\n\r\nlet YAML_DATE_REGEXP = new RegExp(\r\n    '^([0-9][0-9][0-9][0-9])' + // [1] year\r\n    '-([0-9][0-9])' + // [2] month\r\n    '-([0-9][0-9])$'); // [3] day\r\n\r\nlet YAML_TIMESTAMP_REGEXP = new RegExp(\r\n    '^([0-9][0-9][0-9][0-9])' + // [1] year\r\n    '-([0-9][0-9]?)' + // [2] month\r\n    '-([0-9][0-9]?)' + // [3] day\r\n    '(?:[Tt]|[ \\\\t]+)' + // ...\r\n    '([0-9][0-9]?)' + // [4] hour\r\n    ':([0-9][0-9])' + // [5] minute\r\n    ':([0-9][0-9])' + // [6] second\r\n    '(?:\\\\.([0-9]*))?' + // [7] fraction\r\n    '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\r\n    '(?::([0-9][0-9]))?))?$'); // [11] tz_minute\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlTimestamp(data) {\r\n    if (data === null) {\r\n        return false;\r\n    }\r\n    if (YAML_DATE_REGEXP.exec(data) !== null) {\r\n        return true;\r\n    }\r\n    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction constructYamlTimestamp(data) {\r\n    let match, year, month, day, hour, minute, second,\r\n        fraction = 0,\r\n        delta = null,\r\n        tz_hour, tz_minute, date;\r\n\r\n    match = YAML_DATE_REGEXP.exec(data);\r\n    if (match === null) {\r\n        match = YAML_TIMESTAMP_REGEXP.exec(data);\r\n    }\r\n\r\n    if (match === null) {\r\n        throw new Error('Date resolve error');\r\n    }\r\n\r\n    // Match: [1] year [2] month [3] day\r\n\r\n    year = +(match[1]);\r\n    month = +(match[2]) - 1; // JS month starts with 0\r\n    day = +(match[3]);\r\n\r\n    if (!match[4]) { // No hour\r\n        return new Date(Date.UTC(year, month, day));\r\n    }\r\n\r\n    // Match: [4] hour [5] minute [6] second [7] fraction\r\n\r\n    hour = +(match[4]);\r\n    minute = +(match[5]);\r\n    second = +(match[6]);\r\n\r\n    if (match[7]) {\r\n        fraction = match[7].slice(0, 3);\r\n        while (fraction.length < 3) { // Milli-seconds\r\n            fraction += '0';\r\n        }\r\n        fraction = +fraction;\r\n    }\r\n\r\n    // Match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\r\n\r\n    if (match[9]) {\r\n        tz_hour = +(match[10]);\r\n        tz_minute = +(match[11] || 0);\r\n        delta = (tz_hour * 60 + tz_minute) * 60000; // Delta in mili-seconds\r\n        if (match[9] === '-') {\r\n            delta = -delta;\r\n        }\r\n    }\r\n\r\n    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\r\n\r\n    if (delta) {\r\n        date.setTime(date.getTime() - delta);\r\n    }\r\n\r\n    return date;\r\n}\r\n\r\n/**\r\n *\r\n * @param object\r\n */\r\nfunction representYamlTimestamp(object /* , style*/) {\r\n    return object.toISOString();\r\n}\r\n\r\nlet timestamp = new type('tag:yaml.org,2002:timestamp', {\r\n    kind: 'scalar',\r\n    resolve: resolveYamlTimestamp,\r\n    construct: constructYamlTimestamp,\r\n    instanceOf: Date,\r\n    represent: representYamlTimestamp\r\n});\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlMerge(data) {\r\n    return data === '<<' || data === null;\r\n}\r\n\r\nlet merge = new type('tag:yaml.org,2002:merge', {\r\n    kind: 'scalar',\r\n    resolve: resolveYamlMerge\r\n});\r\n\r\n/* eslint-disable no-bitwise*/\r\n\r\n\r\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\r\nlet BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\r\n\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlBinary(data) {\r\n    if (data === null) {\r\n        return false;\r\n    }\r\n\r\n    let code, idx,\r\n        bitlen = 0,\r\n        max = data.length,\r\n        map = BASE64_MAP;\r\n\r\n    // Convert one by one.\r\n    for (idx = 0; idx < max; idx++) {\r\n        code = map.indexOf(data.charAt(idx));\r\n\r\n        // Skip CR/LF\r\n        if (code > 64) {\r\n            continue;\r\n        }\r\n\r\n        // Fail on illegal characters\r\n        if (code < 0) {\r\n            return false;\r\n        }\r\n\r\n        bitlen += 6;\r\n    }\r\n\r\n    // If there are any bits left, source was corrupted\r\n    return (bitlen % 8) === 0;\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction constructYamlBinary(data) {\r\n    let idx, tailbits,\r\n        input = data.replace(/[\\r\\n=]/g, ''), // Remove CR/LF & padding to simplify scan\r\n        max = input.length,\r\n        map = BASE64_MAP,\r\n        bits = 0,\r\n        result = [];\r\n\r\n    // Collect by 6*4 bits (3 bytes)\r\n\r\n    for (idx = 0; idx < max; idx++) {\r\n        if ((idx % 4 === 0) && idx) {\r\n            result.push((bits >> 16) & 0xFF);\r\n            result.push((bits >> 8) & 0xFF);\r\n            result.push(bits & 0xFF);\r\n        }\r\n\r\n        bits = (bits << 6) | map.indexOf(input.charAt(idx));\r\n    }\r\n\r\n    // Dump tail\r\n\r\n    tailbits = (max % 4) * 6;\r\n\r\n    if (tailbits === 0) {\r\n        result.push((bits >> 16) & 0xFF);\r\n        result.push((bits >> 8) & 0xFF);\r\n        result.push(bits & 0xFF);\r\n    } else if (tailbits === 18) {\r\n        result.push((bits >> 10) & 0xFF);\r\n        result.push((bits >> 2) & 0xFF);\r\n    } else if (tailbits === 12) {\r\n        result.push((bits >> 4) & 0xFF);\r\n    }\r\n\r\n    return new Uint8Array(result);\r\n}\r\n\r\n/**\r\n *\r\n * @param object\r\n */\r\nfunction representYamlBinary(object /* , style*/) {\r\n    let result = '',\r\n        bits = 0,\r\n        idx, tail,\r\n        max = object.length,\r\n        map = BASE64_MAP;\r\n\r\n    // Convert every three bytes to 4 ASCII characters.\r\n\r\n    for (idx = 0; idx < max; idx++) {\r\n        if ((idx % 3 === 0) && idx) {\r\n            result += map[(bits >> 18) & 0x3F];\r\n            result += map[(bits >> 12) & 0x3F];\r\n            result += map[(bits >> 6) & 0x3F];\r\n            result += map[bits & 0x3F];\r\n        }\r\n\r\n        bits = (bits << 8) + object[idx];\r\n    }\r\n\r\n    // Dump tail\r\n\r\n    tail = max % 3;\r\n\r\n    if (tail === 0) {\r\n        result += map[(bits >> 18) & 0x3F];\r\n        result += map[(bits >> 12) & 0x3F];\r\n        result += map[(bits >> 6) & 0x3F];\r\n        result += map[bits & 0x3F];\r\n    } else if (tail === 2) {\r\n        result += map[(bits >> 10) & 0x3F];\r\n        result += map[(bits >> 4) & 0x3F];\r\n        result += map[(bits << 2) & 0x3F];\r\n        result += map[64];\r\n    } else if (tail === 1) {\r\n        result += map[(bits >> 2) & 0x3F];\r\n        result += map[(bits << 4) & 0x3F];\r\n        result += map[64];\r\n        result += map[64];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n *\r\n * @param obj\r\n */\r\nfunction isBinary(obj) {\r\n    return Object.prototype.toString.call(obj) === '[object Uint8Array]';\r\n}\r\n\r\nlet binary = new type('tag:yaml.org,2002:binary', {\r\n    kind: 'scalar',\r\n    resolve: resolveYamlBinary,\r\n    construct: constructYamlBinary,\r\n    predicate: isBinary,\r\n    represent: representYamlBinary\r\n});\r\n\r\nlet _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\r\nlet _toString$2 = Object.prototype.toString;\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlOmap(data) {\r\n    if (data === null) {\r\n        return true;\r\n    }\r\n\r\n    let objectKeys = [],\r\n        index, length, pair, pairKey, pairHasKey,\r\n        object = data;\r\n\r\n    for (index = 0, length = object.length; index < length; index += 1) {\r\n        pair = object[index];\r\n        pairHasKey = false;\r\n\r\n        if (_toString$2.call(pair) !== '[object Object]') {\r\n            return false;\r\n        }\r\n\r\n        for (pairKey in pair) {\r\n            if (_hasOwnProperty$3.call(pair, pairKey)) {\r\n                if (!pairHasKey) {\r\n                    pairHasKey = true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!pairHasKey) {\r\n            return false;\r\n        }\r\n\r\n        if (objectKeys.indexOf(pairKey) === -1) {\r\n            objectKeys.push(pairKey);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction constructYamlOmap(data) {\r\n    return data !== null ? data : [];\r\n}\r\n\r\nlet omap = new type('tag:yaml.org,2002:omap', {\r\n    kind: 'sequence',\r\n    resolve: resolveYamlOmap,\r\n    construct: constructYamlOmap\r\n});\r\n\r\nlet _toString$1 = Object.prototype.toString;\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlPairs(data) {\r\n    if (data === null) {\r\n        return true;\r\n    }\r\n\r\n    let index, length, pair, keys, result,\r\n        object = data;\r\n\r\n    result = new Array(object.length);\r\n\r\n    for (index = 0, length = object.length; index < length; index += 1) {\r\n        pair = object[index];\r\n\r\n        if (_toString$1.call(pair) !== '[object Object]') {\r\n            return false;\r\n        }\r\n\r\n        keys = Object.keys(pair);\r\n\r\n        if (keys.length !== 1) {\r\n            return false;\r\n        }\r\n\r\n        result[index] = [keys[0], pair[keys[0]]];\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction constructYamlPairs(data) {\r\n    if (data === null) {\r\n        return [];\r\n    }\r\n\r\n    let index, length, pair, keys, result,\r\n        object = data;\r\n\r\n    result = new Array(object.length);\r\n\r\n    for (index = 0, length = object.length; index < length; index += 1) {\r\n        pair = object[index];\r\n\r\n        keys = Object.keys(pair);\r\n\r\n        result[index] = [keys[0], pair[keys[0]]];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nlet pairs = new type('tag:yaml.org,2002:pairs', {\r\n    kind: 'sequence',\r\n    resolve: resolveYamlPairs,\r\n    construct: constructYamlPairs\r\n});\r\n\r\nlet _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction resolveYamlSet(data) {\r\n    if (data === null) {\r\n        return true;\r\n    }\r\n\r\n    let key,\r\n        object = data;\r\n\r\n    for (key in object) {\r\n        if (_hasOwnProperty$2.call(object, key)) {\r\n            if (object[key] !== null) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param data\r\n */\r\nfunction constructYamlSet(data) {\r\n    return data !== null ? data : {};\r\n}\r\n\r\nlet set = new type('tag:yaml.org,2002:set', {\r\n    kind: 'mapping',\r\n    resolve: resolveYamlSet,\r\n    construct: constructYamlSet\r\n});\r\n\r\nlet _default = core.extend({\r\n    implicit: [\r\n        timestamp,\r\n        merge\r\n    ],\r\n    explicit: [\r\n        binary,\r\n        omap,\r\n        pairs,\r\n        set\r\n    ]\r\n});\r\n\r\n/* eslint-disable max-len*/\r\n\r\n\r\nlet _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\r\n\r\n\r\nlet CONTEXT_FLOW_IN = 1;\r\nlet CONTEXT_FLOW_OUT = 2;\r\nlet CONTEXT_BLOCK_IN = 3;\r\nlet CONTEXT_BLOCK_OUT = 4;\r\n\r\n\r\nlet CHOMPING_CLIP = 1;\r\nlet CHOMPING_STRIP = 2;\r\nlet CHOMPING_KEEP = 3;\r\n\r\n\r\nlet PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\r\nlet PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\r\nlet PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\r\nlet PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\r\nlet PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\r\n\r\n\r\n/**\r\n *\r\n * @param obj\r\n */\r\nfunction _class(obj) {\r\n    return Object.prototype.toString.call(obj);\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction is_EOL(c) {\r\n    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction is_WHITE_SPACE(c) {\r\n    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction is_WS_OR_EOL(c) {\r\n    return (c === 0x09/* Tab */) ||\r\n        (c === 0x20/* Space */) ||\r\n        (c === 0x0A/* LF */) ||\r\n        (c === 0x0D/* CR */);\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction is_FLOW_INDICATOR(c) {\r\n    return c === 0x2C/* , */ ||\r\n        c === 0x5B/* [ */ ||\r\n        c === 0x5D/* ] */ ||\r\n        c === 0x7B/* { */ ||\r\n        c === 0x7D/* } */;\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction fromHexCode(c) {\r\n    let lc;\r\n\r\n    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\r\n        return c - 0x30;\r\n    }\r\n\r\n    /* eslint-disable no-bitwise*/\r\n    lc = c | 0x20;\r\n\r\n    if ((0x61/* A */ <= lc) && (lc <= 0x66/* F */)) {\r\n        return lc - 0x61 + 10;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction escapedHexLen(c) {\r\n    if (c === 0x78/* X */) {\r\n        return 2;\r\n    }\r\n    if (c === 0x75/* U */) {\r\n        return 4;\r\n    }\r\n    if (c === 0x55/* U */) {\r\n        return 8;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction fromDecimalCode(c) {\r\n    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\r\n        return c - 0x30;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction simpleEscapeSequence(c) {\r\n\r\n    return (c === 0x30/* 0 */) ? '\\x00' :\r\n        (c === 0x61/* A */) ? '\\x07' :\r\n            (c === 0x62/* B */) ? '\\x08' :\r\n                (c === 0x74/* T */) ? '\\x09' :\r\n                    (c === 0x09/* Tab */) ? '\\x09' :\r\n                        (c === 0x6E/* N */) ? '\\x0A' :\r\n                            (c === 0x76/* V */) ? '\\x0B' :\r\n                                (c === 0x66/* F */) ? '\\x0C' :\r\n                                    (c === 0x72/* R */) ? '\\x0D' :\r\n                                        (c === 0x65/* E */) ? '\\x1B' :\r\n                                            (c === 0x20/* Space */) ? ' ' :\r\n                                                (c === 0x22/* \" */) ? '\\x22' :\r\n                                                    (c === 0x2F/* / */) ? '/' :\r\n                                                        (c === 0x5C/* \\ */) ? '\\x5C' :\r\n                                                            (c === 0x4E/* N */) ? '\\x85' :\r\n                                                                (c === 0x5F/* _ */) ? '\\xA0' :\r\n                                                                    (c === 0x4C/* L */) ? '\\u2028' :\r\n                                                                        (c === 0x50/* P */) ? '\\u2029' : '';\r\n}\r\n\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction charFromCodepoint(c) {\r\n    if (c <= 0xFFFF) {\r\n        return String.fromCharCode(c);\r\n    }\r\n    // Encode UTF-16 surrogate pair\r\n    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\r\n    return String.fromCharCode(\r\n        ((c - 0x010000) >> 10) + 0xD800,\r\n        ((c - 0x010000) & 0x03FF) + 0xDC00\r\n    );\r\n}\r\n\r\nlet simpleEscapeCheck = new Array(256); // Integer, for fast access\r\nlet simpleEscapeMap = new Array(256);\r\nfor (let i = 0; i < 256; i++) {\r\n    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\r\n    simpleEscapeMap[i] = simpleEscapeSequence(i);\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param input\r\n * @param options\r\n */\r\nfunction State$1(input, options) {\r\n    this.input = input;\r\n\r\n    this.filename = options.filename || null;\r\n    this.schema = options.schema || _default;\r\n    this.onWarning = options.onWarning || null;\r\n    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\r\n    // if such documents have no explicit %YAML directive\r\n    this.legacy = options.legacy || false;\r\n\r\n    this.json = options.json || false;\r\n    this.listener = options.listener || null;\r\n\r\n    this.implicitTypes = this.schema.compiledImplicit;\r\n    this.typeMap = this.schema.compiledTypeMap;\r\n\r\n    this.length = input.length;\r\n    this.position = 0;\r\n    this.line = 0;\r\n    this.lineStart = 0;\r\n    this.lineIndent = 0;\r\n\r\n    // Position of first leading tab in the current line,\r\n    // used to make sure there are no tabs in the indentation\r\n    this.firstTabInLine = -1;\r\n\r\n    this.documents = [];\r\n\r\n    /*\r\n    This.version;\r\n    this.checkLineBreaks;\r\n    this.tagMap;\r\n    this.anchorMap;\r\n    this.tag;\r\n    this.anchor;\r\n    this.kind;\r\n    this.result;*/\r\n\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param message\r\n */\r\nfunction generateError(state, message) {\r\n    let mark = {\r\n        name: state.filename,\r\n        buffer: state.input.slice(0, -1), // Omit trailing \\0\r\n        position: state.position,\r\n        line: state.line,\r\n        column: state.position - state.lineStart\r\n    };\r\n\r\n    mark.widget = widget(mark);\r\n\r\n    return new exception(message, mark);\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param message\r\n */\r\nfunction throwError(state, message) {\r\n    throw generateError(state, message);\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param message\r\n */\r\nfunction throwWarning(state, message) {\r\n    if (state.onWarning) {\r\n        state.onWarning.call(null, generateError(state, message));\r\n    }\r\n}\r\n\r\n\r\nlet directiveHandlers = {\r\n\r\n    YAML: function handleYamlDirective(state, name, args) {\r\n\r\n        let match, major, minor;\r\n\r\n        if (state.version !== null) {\r\n            throwError(state, 'duplication of %YAML directive');\r\n        }\r\n\r\n        if (args.length !== 1) {\r\n            throwError(state, 'YAML directive accepts exactly one argument');\r\n        }\r\n\r\n        match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\r\n\r\n        if (match === null) {\r\n            throwError(state, 'ill-formed argument of the YAML directive');\r\n        }\r\n\r\n        major = parseInt(match[1], 10);\r\n        minor = parseInt(match[2], 10);\r\n\r\n        if (major !== 1) {\r\n            throwError(state, 'unacceptable YAML version of the document');\r\n        }\r\n\r\n        state.version = args[0];\r\n        state.checkLineBreaks = (minor < 2);\r\n\r\n        if (minor !== 1 && minor !== 2) {\r\n            throwWarning(state, 'unsupported YAML version of the document');\r\n        }\r\n    },\r\n\r\n    TAG: function handleTagDirective(state, name, args) {\r\n\r\n        let handle, prefix;\r\n\r\n        if (args.length !== 2) {\r\n            throwError(state, 'TAG directive accepts exactly two arguments');\r\n        }\r\n\r\n        handle = args[0];\r\n        prefix = args[1];\r\n\r\n        if (!PATTERN_TAG_HANDLE.test(handle)) {\r\n            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\r\n        }\r\n\r\n        if (_hasOwnProperty$1.call(state.tagMap, handle)) {\r\n            throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\r\n        }\r\n\r\n        if (!PATTERN_TAG_URI.test(prefix)) {\r\n            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\r\n        }\r\n\r\n        try {\r\n            prefix = decodeURIComponent(prefix);\r\n        } catch (err) {\r\n            throwError(state, 'tag prefix is malformed: ' + prefix);\r\n        }\r\n\r\n        state.tagMap[handle] = prefix;\r\n    }\r\n};\r\n\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param start\r\n * @param end\r\n * @param checkJson\r\n */\r\nfunction captureSegment(state, start, end, checkJson) {\r\n    let _position, _length, _character, _result;\r\n\r\n    if (start < end) {\r\n        _result = state.input.slice(start, end);\r\n\r\n        if (checkJson) {\r\n            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\r\n                _character = _result.charCodeAt(_position);\r\n                if (!(_character === 0x09 ||\r\n                    (0x20 <= _character && _character <= 0x10FFFF))) {\r\n                    throwError(state, 'expected valid JSON character');\r\n                }\r\n            }\r\n        } else if (PATTERN_NON_PRINTABLE.test(_result)) {\r\n            throwError(state, 'the stream contains non-printable characters');\r\n        }\r\n\r\n        state.result += _result;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param destination\r\n * @param source\r\n * @param overridableKeys\r\n */\r\nfunction mergeMappings(state, destination, source, overridableKeys) {\r\n    let sourceKeys, key, index, quantity;\r\n\r\n    if (!common.isObject(source)) {\r\n        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\r\n    }\r\n\r\n    sourceKeys = Object.keys(source);\r\n\r\n    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\r\n        key = sourceKeys[index];\r\n\r\n        if (!_hasOwnProperty$1.call(destination, key)) {\r\n            destination[key] = source[key];\r\n            overridableKeys[key] = true;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param _result\r\n * @param overridableKeys\r\n * @param keyTag\r\n * @param keyNode\r\n * @param valueNode\r\n * @param startLine\r\n * @param startLineStart\r\n * @param startPos\r\n */\r\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\r\n    startLine, startLineStart, startPos) {\r\n\r\n    let index, quantity;\r\n\r\n    // The output is a plain object here, so keys can only be strings.\r\n    // We need to convert keyNode to a string, but doing so can hang the process\r\n    // (deeply nested arrays that explode exponentially using aliases).\r\n    if (Array.isArray(keyNode)) {\r\n        keyNode = Array.prototype.slice.call(keyNode);\r\n\r\n        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\r\n            if (Array.isArray(keyNode[index])) {\r\n                throwError(state, 'nested arrays are not supported inside keys');\r\n            }\r\n\r\n            if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\r\n                keyNode[index] = '[object Object]';\r\n            }\r\n        }\r\n    }\r\n\r\n    // Avoid code execution in load() via toString property\r\n    // (still use its own toString for arrays, timestamps,\r\n    // and whatever user schema extensions happen to have @@toStringTag)\r\n    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\r\n        keyNode = '[object Object]';\r\n    }\r\n\r\n\r\n    keyNode = String(keyNode);\r\n\r\n    if (_result === null) {\r\n        _result = {};\r\n    }\r\n\r\n    if (keyTag === 'tag:yaml.org,2002:merge') {\r\n        if (Array.isArray(valueNode)) {\r\n            for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\r\n                mergeMappings(state, _result, valueNode[index], overridableKeys);\r\n            }\r\n        } else {\r\n            mergeMappings(state, _result, valueNode, overridableKeys);\r\n        }\r\n    } else {\r\n        if (!state.json &&\r\n            !_hasOwnProperty$1.call(overridableKeys, keyNode) &&\r\n            _hasOwnProperty$1.call(_result, keyNode)) {\r\n            state.line = startLine || state.line;\r\n            state.lineStart = startLineStart || state.lineStart;\r\n            state.position = startPos || state.position;\r\n            throwError(state, 'duplicated mapping key');\r\n        }\r\n\r\n        // Used for this specific key only because Object.defineProperty is slow\r\n        if (keyNode === '__proto__') {\r\n            Object.defineProperty(_result, keyNode, {\r\n                configurable: true,\r\n                enumerable: true,\r\n                writable: true,\r\n                value: valueNode\r\n            });\r\n        } else {\r\n            _result[keyNode] = valueNode;\r\n        }\r\n        delete overridableKeys[keyNode];\r\n    }\r\n\r\n    return _result;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n */\r\nfunction readLineBreak(state) {\r\n    let ch;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (ch === 0x0A/* LF */) {\r\n        state.position++;\r\n    } else if (ch === 0x0D/* CR */) {\r\n        state.position++;\r\n        if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\r\n            state.position++;\r\n        }\r\n    } else {\r\n        throwError(state, 'a line break is expected');\r\n    }\r\n\r\n    state.line += 1;\r\n    state.lineStart = state.position;\r\n    state.firstTabInLine = -1;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param allowComments\r\n * @param checkIndent\r\n */\r\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\r\n    let lineBreaks = 0,\r\n        ch = state.input.charCodeAt(state.position);\r\n\r\n    while (ch !== 0) {\r\n        while (is_WHITE_SPACE(ch)) {\r\n            if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\r\n                state.firstTabInLine = state.position;\r\n            }\r\n            ch = state.input.charCodeAt(++state.position);\r\n        }\r\n\r\n        if (allowComments && ch === 0x23/* # */) {\r\n            do {\r\n                ch = state.input.charCodeAt(++state.position);\r\n            } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\r\n        }\r\n\r\n        if (is_EOL(ch)) {\r\n            readLineBreak(state);\r\n\r\n            ch = state.input.charCodeAt(state.position);\r\n            lineBreaks++;\r\n            state.lineIndent = 0;\r\n\r\n            while (ch === 0x20/* Space */) {\r\n                state.lineIndent++;\r\n                ch = state.input.charCodeAt(++state.position);\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\r\n        throwWarning(state, 'deficient indentation');\r\n    }\r\n\r\n    return lineBreaks;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n */\r\nfunction testDocumentSeparator(state) {\r\n    let _position = state.position,\r\n        ch;\r\n\r\n    ch = state.input.charCodeAt(_position);\r\n\r\n    // Condition state.position === state.lineStart is tested\r\n    // in parent on each call, for efficiency. No needs to test here again.\r\n    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\r\n        ch === state.input.charCodeAt(_position + 1) &&\r\n        ch === state.input.charCodeAt(_position + 2)) {\r\n\r\n        _position += 3;\r\n\r\n        ch = state.input.charCodeAt(_position);\r\n\r\n        if (ch === 0 || is_WS_OR_EOL(ch)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param count\r\n */\r\nfunction writeFoldedLines(state, count) {\r\n    if (count === 1) {\r\n        state.result += ' ';\r\n    } else if (count > 1) {\r\n        state.result += common.repeat('\\n', count - 1);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param nodeIndent\r\n * @param withinFlowCollection\r\n */\r\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\r\n    let preceding,\r\n        following,\r\n        captureStart,\r\n        captureEnd,\r\n        hasPendingContent,\r\n        _line,\r\n        _lineStart,\r\n        _lineIndent,\r\n        _kind = state.kind,\r\n        _result = state.result,\r\n        ch;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (is_WS_OR_EOL(ch) ||\r\n        is_FLOW_INDICATOR(ch) ||\r\n        ch === 0x23/* # */ ||\r\n        ch === 0x26/* & */ ||\r\n        ch === 0x2A/* * */ ||\r\n        ch === 0x21/* ! */ ||\r\n        ch === 0x7C/* | */ ||\r\n        ch === 0x3E/* > */ ||\r\n        ch === 0x27/* ' */ ||\r\n        ch === 0x22/* \" */ ||\r\n        ch === 0x25/* % */ ||\r\n        ch === 0x40/* @ */ ||\r\n        ch === 0x60/* ` */) {\r\n        return false;\r\n    }\r\n\r\n    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\r\n        following = state.input.charCodeAt(state.position + 1);\r\n\r\n        if (is_WS_OR_EOL(following) ||\r\n            withinFlowCollection && is_FLOW_INDICATOR(following)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    state.kind = 'scalar';\r\n    state.result = '';\r\n    captureStart = captureEnd = state.position;\r\n    hasPendingContent = false;\r\n\r\n    while (ch !== 0) {\r\n        if (ch === 0x3A/* : */) {\r\n            following = state.input.charCodeAt(state.position + 1);\r\n\r\n            if (is_WS_OR_EOL(following) ||\r\n                withinFlowCollection && is_FLOW_INDICATOR(following)) {\r\n                break;\r\n            }\r\n\r\n        } else if (ch === 0x23/* # */) {\r\n            preceding = state.input.charCodeAt(state.position - 1);\r\n\r\n            if (is_WS_OR_EOL(preceding)) {\r\n                break;\r\n            }\r\n\r\n        } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\r\n            withinFlowCollection && is_FLOW_INDICATOR(ch)) {\r\n            break;\r\n\r\n        } else if (is_EOL(ch)) {\r\n            _line = state.line;\r\n            _lineStart = state.lineStart;\r\n            _lineIndent = state.lineIndent;\r\n            skipSeparationSpace(state, false, -1);\r\n\r\n            if (state.lineIndent >= nodeIndent) {\r\n                hasPendingContent = true;\r\n                ch = state.input.charCodeAt(state.position);\r\n                continue;\r\n            } else {\r\n                state.position = captureEnd;\r\n                state.line = _line;\r\n                state.lineStart = _lineStart;\r\n                state.lineIndent = _lineIndent;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (hasPendingContent) {\r\n            captureSegment(state, captureStart, captureEnd, false);\r\n            writeFoldedLines(state, state.line - _line);\r\n            captureStart = captureEnd = state.position;\r\n            hasPendingContent = false;\r\n        }\r\n\r\n        if (!is_WHITE_SPACE(ch)) {\r\n            captureEnd = state.position + 1;\r\n        }\r\n\r\n        ch = state.input.charCodeAt(++state.position);\r\n    }\r\n\r\n    captureSegment(state, captureStart, captureEnd, false);\r\n\r\n    if (state.result) {\r\n        return true;\r\n    }\r\n\r\n    state.kind = _kind;\r\n    state.result = _result;\r\n    return false;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param nodeIndent\r\n */\r\nfunction readSingleQuotedScalar(state, nodeIndent) {\r\n    let ch,\r\n        captureStart, captureEnd;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (ch !== 0x27/* ' */) {\r\n        return false;\r\n    }\r\n\r\n    state.kind = 'scalar';\r\n    state.result = '';\r\n    state.position++;\r\n    captureStart = captureEnd = state.position;\r\n\r\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\r\n        if (ch === 0x27/* ' */) {\r\n            captureSegment(state, captureStart, state.position, true);\r\n            ch = state.input.charCodeAt(++state.position);\r\n\r\n            if (ch === 0x27/* ' */) {\r\n                captureStart = state.position;\r\n                state.position++;\r\n                captureEnd = state.position;\r\n            } else {\r\n                return true;\r\n            }\r\n\r\n        } else if (is_EOL(ch)) {\r\n            captureSegment(state, captureStart, captureEnd, true);\r\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\r\n            captureStart = captureEnd = state.position;\r\n\r\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\r\n            throwError(state, 'unexpected end of the document within a single quoted scalar');\r\n\r\n        } else {\r\n            state.position++;\r\n            captureEnd = state.position;\r\n        }\r\n    }\r\n\r\n    throwError(state, 'unexpected end of the stream within a single quoted scalar');\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param nodeIndent\r\n */\r\nfunction readDoubleQuotedScalar(state, nodeIndent) {\r\n    let captureStart,\r\n        captureEnd,\r\n        hexLength,\r\n        hexResult,\r\n        tmp,\r\n        ch;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (ch !== 0x22/* \" */) {\r\n        return false;\r\n    }\r\n\r\n    state.kind = 'scalar';\r\n    state.result = '';\r\n    state.position++;\r\n    captureStart = captureEnd = state.position;\r\n\r\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\r\n        if (ch === 0x22/* \" */) {\r\n            captureSegment(state, captureStart, state.position, true);\r\n            state.position++;\r\n            return true;\r\n\r\n        } else if (ch === 0x5C/* \\ */) {\r\n            captureSegment(state, captureStart, state.position, true);\r\n            ch = state.input.charCodeAt(++state.position);\r\n\r\n            if (is_EOL(ch)) {\r\n                skipSeparationSpace(state, false, nodeIndent);\r\n\r\n                // TODO: rework to inline fn with no type cast?\r\n            } else if (ch < 256 && simpleEscapeCheck[ch]) {\r\n                state.result += simpleEscapeMap[ch];\r\n                state.position++;\r\n\r\n            } else if ((tmp = escapedHexLen(ch)) > 0) {\r\n                hexLength = tmp;\r\n                hexResult = 0;\r\n\r\n                for (; hexLength > 0; hexLength--) {\r\n                    ch = state.input.charCodeAt(++state.position);\r\n\r\n                    if ((tmp = fromHexCode(ch)) >= 0) {\r\n                        hexResult = (hexResult << 4) + tmp;\r\n\r\n                    } else {\r\n                        throwError(state, 'expected hexadecimal character');\r\n                    }\r\n                }\r\n\r\n                state.result += charFromCodepoint(hexResult);\r\n\r\n                state.position++;\r\n\r\n            } else {\r\n                throwError(state, 'unknown escape sequence');\r\n            }\r\n\r\n            captureStart = captureEnd = state.position;\r\n\r\n        } else if (is_EOL(ch)) {\r\n            captureSegment(state, captureStart, captureEnd, true);\r\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\r\n            captureStart = captureEnd = state.position;\r\n\r\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\r\n            throwError(state, 'unexpected end of the document within a double quoted scalar');\r\n\r\n        } else {\r\n            state.position++;\r\n            captureEnd = state.position;\r\n        }\r\n    }\r\n\r\n    throwError(state, 'unexpected end of the stream within a double quoted scalar');\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param nodeIndent\r\n */\r\nfunction readFlowCollection(state, nodeIndent) {\r\n    let readNext = true,\r\n        _line,\r\n        _lineStart,\r\n        _pos,\r\n        _tag = state.tag,\r\n        _result,\r\n        _anchor = state.anchor,\r\n        following,\r\n        terminator,\r\n        isPair,\r\n        isExplicitPair,\r\n        isMapping,\r\n        overridableKeys = Object.create(null),\r\n        keyNode,\r\n        keyTag,\r\n        valueNode,\r\n        ch;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (ch === 0x5B/* [ */) {\r\n        terminator = 0x5D;/* ] */\r\n        isMapping = false;\r\n        _result = [];\r\n    } else if (ch === 0x7B/* { */) {\r\n        terminator = 0x7D;/* } */\r\n        isMapping = true;\r\n        _result = {};\r\n    } else {\r\n        return false;\r\n    }\r\n\r\n    if (state.anchor !== null) {\r\n        state.anchorMap[state.anchor] = _result;\r\n    }\r\n\r\n    ch = state.input.charCodeAt(++state.position);\r\n\r\n    while (ch !== 0) {\r\n        skipSeparationSpace(state, true, nodeIndent);\r\n\r\n        ch = state.input.charCodeAt(state.position);\r\n\r\n        if (ch === terminator) {\r\n            state.position++;\r\n            state.tag = _tag;\r\n            state.anchor = _anchor;\r\n            state.kind = isMapping ? 'mapping' : 'sequence';\r\n            state.result = _result;\r\n            return true;\r\n        } else if (!readNext) {\r\n            throwError(state, 'missed comma between flow collection entries');\r\n        } else if (ch === 0x2C/* , */) {\r\n            // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\r\n            throwError(state, \"expected the node content, but found ','\");\r\n        }\r\n\r\n        keyTag = keyNode = valueNode = null;\r\n        isPair = isExplicitPair = false;\r\n\r\n        if (ch === 0x3F/* ? */) {\r\n            following = state.input.charCodeAt(state.position + 1);\r\n\r\n            if (is_WS_OR_EOL(following)) {\r\n                isPair = isExplicitPair = true;\r\n                state.position++;\r\n                skipSeparationSpace(state, true, nodeIndent);\r\n            }\r\n        }\r\n\r\n        _line = state.line; // Save the current line.\r\n        _lineStart = state.lineStart;\r\n        _pos = state.position;\r\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\r\n        keyTag = state.tag;\r\n        keyNode = state.result;\r\n        skipSeparationSpace(state, true, nodeIndent);\r\n\r\n        ch = state.input.charCodeAt(state.position);\r\n\r\n        if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\r\n            isPair = true;\r\n            ch = state.input.charCodeAt(++state.position);\r\n            skipSeparationSpace(state, true, nodeIndent);\r\n            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\r\n            valueNode = state.result;\r\n        }\r\n\r\n        if (isMapping) {\r\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\r\n        } else if (isPair) {\r\n            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\r\n        } else {\r\n            _result.push(keyNode);\r\n        }\r\n\r\n        skipSeparationSpace(state, true, nodeIndent);\r\n\r\n        ch = state.input.charCodeAt(state.position);\r\n\r\n        if (ch === 0x2C/* , */) {\r\n            readNext = true;\r\n            ch = state.input.charCodeAt(++state.position);\r\n        } else {\r\n            readNext = false;\r\n        }\r\n    }\r\n\r\n    throwError(state, 'unexpected end of the stream within a flow collection');\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param nodeIndent\r\n */\r\nfunction readBlockScalar(state, nodeIndent) {\r\n    let captureStart,\r\n        folding,\r\n        chomping = CHOMPING_CLIP,\r\n        didReadContent = false,\r\n        detectedIndent = false,\r\n        textIndent = nodeIndent,\r\n        emptyLines = 0,\r\n        atMoreIndented = false,\r\n        tmp,\r\n        ch;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (ch === 0x7C/* | */) {\r\n        folding = false;\r\n    } else if (ch === 0x3E/* > */) {\r\n        folding = true;\r\n    } else {\r\n        return false;\r\n    }\r\n\r\n    state.kind = 'scalar';\r\n    state.result = '';\r\n\r\n    while (ch !== 0) {\r\n        ch = state.input.charCodeAt(++state.position);\r\n\r\n        if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\r\n            if (CHOMPING_CLIP === chomping) {\r\n                chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\r\n            } else {\r\n                throwError(state, 'repeat of a chomping mode identifier');\r\n            }\r\n\r\n        } else if ((tmp = fromDecimalCode(ch)) >= 0) {\r\n            if (tmp === 0) {\r\n                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\r\n            } else if (!detectedIndent) {\r\n                textIndent = nodeIndent + tmp - 1;\r\n                detectedIndent = true;\r\n            } else {\r\n                throwError(state, 'repeat of an indentation width identifier');\r\n            }\r\n\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (is_WHITE_SPACE(ch)) {\r\n        do {\r\n            ch = state.input.charCodeAt(++state.position);\r\n        }\r\n        while (is_WHITE_SPACE(ch));\r\n\r\n        if (ch === 0x23/* # */) {\r\n            do {\r\n                ch = state.input.charCodeAt(++state.position);\r\n            }\r\n            while (!is_EOL(ch) && (ch !== 0));\r\n        }\r\n    }\r\n\r\n    while (ch !== 0) {\r\n        readLineBreak(state);\r\n        state.lineIndent = 0;\r\n\r\n        ch = state.input.charCodeAt(state.position);\r\n\r\n        while ((!detectedIndent || state.lineIndent < textIndent) &&\r\n            (ch === 0x20/* Space */)) {\r\n            state.lineIndent++;\r\n            ch = state.input.charCodeAt(++state.position);\r\n        }\r\n\r\n        if (!detectedIndent && state.lineIndent > textIndent) {\r\n            textIndent = state.lineIndent;\r\n        }\r\n\r\n        if (is_EOL(ch)) {\r\n            emptyLines++;\r\n            continue;\r\n        }\r\n\r\n        // End of the scalar.\r\n        if (state.lineIndent < textIndent) {\r\n\r\n            // Perform the chomping.\r\n            if (chomping === CHOMPING_KEEP) {\r\n                state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\r\n            } else if (chomping === CHOMPING_CLIP) {\r\n                if (didReadContent) { // I.e. only if the scalar is not empty.\r\n                    state.result += '\\n';\r\n                }\r\n            }\r\n\r\n            // Break this `while` cycle and go to the funciton's epilogue.\r\n            break;\r\n        }\r\n\r\n        // Folded style: use fancy rules to handle line breaks.\r\n        if (folding) {\r\n\r\n            // Lines starting with white space characters (more-indented lines) are not folded.\r\n            if (is_WHITE_SPACE(ch)) {\r\n                atMoreIndented = true;\r\n                // Except for the first content line (cf. Example 8.1)\r\n                state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\r\n\r\n                // End of more-indented block.\r\n            } else if (atMoreIndented) {\r\n                atMoreIndented = false;\r\n                state.result += common.repeat('\\n', emptyLines + 1);\r\n\r\n                // Just one line break - perceive as the same line.\r\n            } else if (emptyLines === 0) {\r\n                if (didReadContent) { // I.e. only if we have already read some scalar content.\r\n                    state.result += ' ';\r\n                }\r\n\r\n                // Several line breaks - perceive as different lines.\r\n            } else {\r\n                state.result += common.repeat('\\n', emptyLines);\r\n            }\r\n\r\n            // Literal style: just add exact number of line breaks between content lines.\r\n        } else {\r\n            // Keep all line breaks except the header line break.\r\n            state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\r\n        }\r\n\r\n        didReadContent = true;\r\n        detectedIndent = true;\r\n        emptyLines = 0;\r\n        captureStart = state.position;\r\n\r\n        while (!is_EOL(ch) && (ch !== 0)) {\r\n            ch = state.input.charCodeAt(++state.position);\r\n        }\r\n\r\n        captureSegment(state, captureStart, state.position, false);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param nodeIndent\r\n */\r\nfunction readBlockSequence(state, nodeIndent) {\r\n    let _line,\r\n        _tag = state.tag,\r\n        _anchor = state.anchor,\r\n        _result = [],\r\n        following,\r\n        detected = false,\r\n        ch;\r\n\r\n    // There is a leading tab before this token, so it can't be a block sequence/mapping;\r\n    // it can still be flow sequence/mapping or a scalar\r\n    if (state.firstTabInLine !== -1) {\r\n        return false;\r\n    }\r\n\r\n    if (state.anchor !== null) {\r\n        state.anchorMap[state.anchor] = _result;\r\n    }\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    while (ch !== 0) {\r\n        if (state.firstTabInLine !== -1) {\r\n            state.position = state.firstTabInLine;\r\n            throwError(state, 'tab characters must not be used in indentation');\r\n        }\r\n\r\n        if (ch !== 0x2D/* - */) {\r\n            break;\r\n        }\r\n\r\n        following = state.input.charCodeAt(state.position + 1);\r\n\r\n        if (!is_WS_OR_EOL(following)) {\r\n            break;\r\n        }\r\n\r\n        detected = true;\r\n        state.position++;\r\n\r\n        if (skipSeparationSpace(state, true, -1)) {\r\n            if (state.lineIndent <= nodeIndent) {\r\n                _result.push(null);\r\n                ch = state.input.charCodeAt(state.position);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        _line = state.line;\r\n        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\r\n        _result.push(state.result);\r\n        skipSeparationSpace(state, true, -1);\r\n\r\n        ch = state.input.charCodeAt(state.position);\r\n\r\n        if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\r\n            throwError(state, 'bad indentation of a sequence entry');\r\n        } else if (state.lineIndent < nodeIndent) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (detected) {\r\n        state.tag = _tag;\r\n        state.anchor = _anchor;\r\n        state.kind = 'sequence';\r\n        state.result = _result;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param nodeIndent\r\n * @param flowIndent\r\n */\r\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\r\n    let following,\r\n        allowCompact,\r\n        _line,\r\n        _keyLine,\r\n        _keyLineStart,\r\n        _keyPos,\r\n        _tag = state.tag,\r\n        _anchor = state.anchor,\r\n        _result = {},\r\n        overridableKeys = Object.create(null),\r\n        keyTag = null,\r\n        keyNode = null,\r\n        valueNode = null,\r\n        atExplicitKey = false,\r\n        detected = false,\r\n        ch;\r\n\r\n    // There is a leading tab before this token, so it can't be a block sequence/mapping;\r\n    // it can still be flow sequence/mapping or a scalar\r\n    if (state.firstTabInLine !== -1) {\r\n        return false;\r\n    }\r\n\r\n    if (state.anchor !== null) {\r\n        state.anchorMap[state.anchor] = _result;\r\n    }\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    while (ch !== 0) {\r\n        if (!atExplicitKey && state.firstTabInLine !== -1) {\r\n            state.position = state.firstTabInLine;\r\n            throwError(state, 'tab characters must not be used in indentation');\r\n        }\r\n\r\n        following = state.input.charCodeAt(state.position + 1);\r\n        _line = state.line; // Save the current line.\r\n\r\n        //\r\n        // Explicit notation case. There are two separate blocks:\r\n        // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\r\n        //\r\n        if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\r\n\r\n            if (ch === 0x3F/* ? */) {\r\n                if (atExplicitKey) {\r\n                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\r\n                    keyTag = keyNode = valueNode = null;\r\n                }\r\n\r\n                detected = true;\r\n                atExplicitKey = true;\r\n                allowCompact = true;\r\n\r\n            } else if (atExplicitKey) {\r\n                // I.e. 0x3A/* : */ === character after the explicit key.\r\n                atExplicitKey = false;\r\n                allowCompact = true;\r\n\r\n            } else {\r\n                throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\r\n            }\r\n\r\n            state.position += 1;\r\n            ch = following;\r\n\r\n            //\r\n            // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\r\n            //\r\n        } else {\r\n            _keyLine = state.line;\r\n            _keyLineStart = state.lineStart;\r\n            _keyPos = state.position;\r\n\r\n            if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\r\n                // Neither implicit nor explicit notation.\r\n                // Reading is done. Go to the epilogue.\r\n                break;\r\n            }\r\n\r\n            if (state.line === _line) {\r\n                ch = state.input.charCodeAt(state.position);\r\n\r\n                while (is_WHITE_SPACE(ch)) {\r\n                    ch = state.input.charCodeAt(++state.position);\r\n                }\r\n\r\n                if (ch === 0x3A/* : */) {\r\n                    ch = state.input.charCodeAt(++state.position);\r\n\r\n                    if (!is_WS_OR_EOL(ch)) {\r\n                        throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\r\n                    }\r\n\r\n                    if (atExplicitKey) {\r\n                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\r\n                        keyTag = keyNode = valueNode = null;\r\n                    }\r\n\r\n                    detected = true;\r\n                    atExplicitKey = false;\r\n                    allowCompact = false;\r\n                    keyTag = state.tag;\r\n                    keyNode = state.result;\r\n\r\n                } else if (detected) {\r\n                    throwError(state, 'can not read an implicit mapping pair; a colon is missed');\r\n\r\n                } else {\r\n                    state.tag = _tag;\r\n                    state.anchor = _anchor;\r\n                    return true; // Keep the result of `composeNode`.\r\n                }\r\n\r\n            } else if (detected) {\r\n                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\r\n\r\n            } else {\r\n                state.tag = _tag;\r\n                state.anchor = _anchor;\r\n                return true; // Keep the result of `composeNode`.\r\n            }\r\n        }\r\n\r\n        //\r\n        // Common reading code for both explicit and implicit notations.\r\n        //\r\n        if (state.line === _line || state.lineIndent > nodeIndent) {\r\n            if (atExplicitKey) {\r\n                _keyLine = state.line;\r\n                _keyLineStart = state.lineStart;\r\n                _keyPos = state.position;\r\n            }\r\n\r\n            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\r\n                if (atExplicitKey) {\r\n                    keyNode = state.result;\r\n                } else {\r\n                    valueNode = state.result;\r\n                }\r\n            }\r\n\r\n            if (!atExplicitKey) {\r\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\r\n                keyTag = keyNode = valueNode = null;\r\n            }\r\n\r\n            skipSeparationSpace(state, true, -1);\r\n            ch = state.input.charCodeAt(state.position);\r\n        }\r\n\r\n        if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\r\n            throwError(state, 'bad indentation of a mapping entry');\r\n        } else if (state.lineIndent < nodeIndent) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    //\r\n    // Epilogue.\r\n    //\r\n\r\n    // Special case: last mapping's node contains only the key in explicit notation.\r\n    if (atExplicitKey) {\r\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\r\n    }\r\n\r\n    // Expose the resulting mapping.\r\n    if (detected) {\r\n        state.tag = _tag;\r\n        state.anchor = _anchor;\r\n        state.kind = 'mapping';\r\n        state.result = _result;\r\n    }\r\n\r\n    return detected;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n */\r\nfunction readTagProperty(state) {\r\n    let _position,\r\n        isVerbatim = false,\r\n        isNamed = false,\r\n        tagHandle,\r\n        tagName,\r\n        ch;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (ch !== 0x21/* ! */) {\r\n        return false;\r\n    }\r\n\r\n    if (state.tag !== null) {\r\n        throwError(state, 'duplication of a tag property');\r\n    }\r\n\r\n    ch = state.input.charCodeAt(++state.position);\r\n\r\n    if (ch === 0x3C/* < */) {\r\n        isVerbatim = true;\r\n        ch = state.input.charCodeAt(++state.position);\r\n\r\n    } else if (ch === 0x21/* ! */) {\r\n        isNamed = true;\r\n        tagHandle = '!!';\r\n        ch = state.input.charCodeAt(++state.position);\r\n\r\n    } else {\r\n        tagHandle = '!';\r\n    }\r\n\r\n    _position = state.position;\r\n\r\n    if (isVerbatim) {\r\n        do {\r\n            ch = state.input.charCodeAt(++state.position);\r\n        }\r\n        while (ch !== 0 && ch !== 0x3E/* > */);\r\n\r\n        if (state.position < state.length) {\r\n            tagName = state.input.slice(_position, state.position);\r\n            ch = state.input.charCodeAt(++state.position);\r\n        } else {\r\n            throwError(state, 'unexpected end of the stream within a verbatim tag');\r\n        }\r\n    } else {\r\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\r\n\r\n            if (ch === 0x21/* ! */) {\r\n                if (!isNamed) {\r\n                    tagHandle = state.input.slice(_position - 1, state.position + 1);\r\n\r\n                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\r\n                        throwError(state, 'named tag handle cannot contain such characters');\r\n                    }\r\n\r\n                    isNamed = true;\r\n                    _position = state.position + 1;\r\n                } else {\r\n                    throwError(state, 'tag suffix cannot contain exclamation marks');\r\n                }\r\n            }\r\n\r\n            ch = state.input.charCodeAt(++state.position);\r\n        }\r\n\r\n        tagName = state.input.slice(_position, state.position);\r\n\r\n        if (PATTERN_FLOW_INDICATORS.test(tagName)) {\r\n            throwError(state, 'tag suffix cannot contain flow indicator characters');\r\n        }\r\n    }\r\n\r\n    if (tagName && !PATTERN_TAG_URI.test(tagName)) {\r\n        throwError(state, 'tag name cannot contain such characters: ' + tagName);\r\n    }\r\n\r\n    try {\r\n        tagName = decodeURIComponent(tagName);\r\n    } catch (err) {\r\n        throwError(state, 'tag name is malformed: ' + tagName);\r\n    }\r\n\r\n    if (isVerbatim) {\r\n        state.tag = tagName;\r\n\r\n    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\r\n        state.tag = state.tagMap[tagHandle] + tagName;\r\n\r\n    } else if (tagHandle === '!') {\r\n        state.tag = '!' + tagName;\r\n\r\n    } else if (tagHandle === '!!') {\r\n        state.tag = 'tag:yaml.org,2002:' + tagName;\r\n\r\n    } else {\r\n        throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n */\r\nfunction readAnchorProperty(state) {\r\n    let _position,\r\n        ch;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (ch !== 0x26/* & */) {\r\n        return false;\r\n    }\r\n\r\n    if (state.anchor !== null) {\r\n        throwError(state, 'duplication of an anchor property');\r\n    }\r\n\r\n    ch = state.input.charCodeAt(++state.position);\r\n    _position = state.position;\r\n\r\n    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\r\n        ch = state.input.charCodeAt(++state.position);\r\n    }\r\n\r\n    if (state.position === _position) {\r\n        throwError(state, 'name of an anchor node must contain at least one character');\r\n    }\r\n\r\n    state.anchor = state.input.slice(_position, state.position);\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n */\r\nfunction readAlias(state) {\r\n    let _position, alias,\r\n        ch;\r\n\r\n    ch = state.input.charCodeAt(state.position);\r\n\r\n    if (ch !== 0x2A/* * */) {\r\n        return false;\r\n    }\r\n\r\n    ch = state.input.charCodeAt(++state.position);\r\n    _position = state.position;\r\n\r\n    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\r\n        ch = state.input.charCodeAt(++state.position);\r\n    }\r\n\r\n    if (state.position === _position) {\r\n        throwError(state, 'name of an alias node must contain at least one character');\r\n    }\r\n\r\n    alias = state.input.slice(_position, state.position);\r\n\r\n    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\r\n        throwError(state, 'unidentified alias \"' + alias + '\"');\r\n    }\r\n\r\n    state.result = state.anchorMap[alias];\r\n    skipSeparationSpace(state, true, -1);\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param parentIndent\r\n * @param nodeContext\r\n * @param allowToSeek\r\n * @param allowCompact\r\n */\r\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\r\n    let allowBlockStyles,\r\n        allowBlockScalars,\r\n        allowBlockCollections,\r\n        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\r\n        atNewLine = false,\r\n        hasContent = false,\r\n        typeIndex,\r\n        typeQuantity,\r\n        typeList,\r\n        type,\r\n        flowIndent,\r\n        blockIndent;\r\n\r\n    if (state.listener !== null) {\r\n        state.listener('open', state);\r\n    }\r\n\r\n    state.tag = null;\r\n    state.anchor = null;\r\n    state.kind = null;\r\n    state.result = null;\r\n\r\n    allowBlockStyles = allowBlockScalars = allowBlockCollections =\r\n        CONTEXT_BLOCK_OUT === nodeContext ||\r\n        CONTEXT_BLOCK_IN === nodeContext;\r\n\r\n    if (allowToSeek) {\r\n        if (skipSeparationSpace(state, true, -1)) {\r\n            atNewLine = true;\r\n\r\n            if (state.lineIndent > parentIndent) {\r\n                indentStatus = 1;\r\n            } else if (state.lineIndent === parentIndent) {\r\n                indentStatus = 0;\r\n            } else if (state.lineIndent < parentIndent) {\r\n                indentStatus = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (indentStatus === 1) {\r\n        while (readTagProperty(state) || readAnchorProperty(state)) {\r\n            if (skipSeparationSpace(state, true, -1)) {\r\n                atNewLine = true;\r\n                allowBlockCollections = allowBlockStyles;\r\n\r\n                if (state.lineIndent > parentIndent) {\r\n                    indentStatus = 1;\r\n                } else if (state.lineIndent === parentIndent) {\r\n                    indentStatus = 0;\r\n                } else if (state.lineIndent < parentIndent) {\r\n                    indentStatus = -1;\r\n                }\r\n            } else {\r\n                allowBlockCollections = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (allowBlockCollections) {\r\n        allowBlockCollections = atNewLine || allowCompact;\r\n    }\r\n\r\n    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\r\n        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\r\n            flowIndent = parentIndent;\r\n        } else {\r\n            flowIndent = parentIndent + 1;\r\n        }\r\n\r\n        blockIndent = state.position - state.lineStart;\r\n\r\n        if (indentStatus === 1) {\r\n            if (allowBlockCollections &&\r\n                (readBlockSequence(state, blockIndent) ||\r\n                    readBlockMapping(state, blockIndent, flowIndent)) ||\r\n                readFlowCollection(state, flowIndent)) {\r\n                hasContent = true;\r\n            } else {\r\n                if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\r\n                    readSingleQuotedScalar(state, flowIndent) ||\r\n                    readDoubleQuotedScalar(state, flowIndent)) {\r\n                    hasContent = true;\r\n\r\n                } else if (readAlias(state)) {\r\n                    hasContent = true;\r\n\r\n                    if (state.tag !== null || state.anchor !== null) {\r\n                        throwError(state, 'alias node should not have any properties');\r\n                    }\r\n\r\n                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\r\n                    hasContent = true;\r\n\r\n                    if (state.tag === null) {\r\n                        state.tag = '?';\r\n                    }\r\n                }\r\n\r\n                if (state.anchor !== null) {\r\n                    state.anchorMap[state.anchor] = state.result;\r\n                }\r\n            }\r\n        } else if (indentStatus === 0) {\r\n            // Special case: block sequences are allowed to have same indentation level as the parent.\r\n            // http://www.yaml.org/spec/1.2/spec.html#id2799784\r\n            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\r\n        }\r\n    }\r\n\r\n    if (state.tag === null) {\r\n        if (state.anchor !== null) {\r\n            state.anchorMap[state.anchor] = state.result;\r\n        }\r\n\r\n    } else if (state.tag === '?') {\r\n        // Implicit resolving is not allowed for non-scalar types, and '?'\r\n        // non-specific tag is only automatically assigned to plain scalars.\r\n        //\r\n        // We only need to check kind conformity in case user explicitly assigns '?'\r\n        // tag, for example like this: \"!<?> [0]\"\r\n        //\r\n        if (state.result !== null && state.kind !== 'scalar') {\r\n            throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\r\n        }\r\n\r\n        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\r\n            type = state.implicitTypes[typeIndex];\r\n\r\n            if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\r\n                state.result = type.construct(state.result);\r\n                state.tag = type.tag;\r\n                if (state.anchor !== null) {\r\n                    state.anchorMap[state.anchor] = state.result;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    } else if (state.tag !== '!') {\r\n        if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\r\n            type = state.typeMap[state.kind || 'fallback'][state.tag];\r\n        } else {\r\n            // Looking for multi type\r\n            type = null;\r\n            typeList = state.typeMap.multi[state.kind || 'fallback'];\r\n\r\n            for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\r\n                if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\r\n                    type = typeList[typeIndex];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!type) {\r\n            throwError(state, 'unknown tag !<' + state.tag + '>');\r\n        }\r\n\r\n        if (state.result !== null && type.kind !== state.kind) {\r\n            throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\r\n        }\r\n\r\n        if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\r\n            throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\r\n        } else {\r\n            state.result = type.construct(state.result, state.tag);\r\n            if (state.anchor !== null) {\r\n                state.anchorMap[state.anchor] = state.result;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (state.listener !== null) {\r\n        state.listener('close', state);\r\n    }\r\n    return state.tag !== null || state.anchor !== null || hasContent;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n */\r\nfunction readDocument(state) {\r\n    let documentStart = state.position,\r\n        _position,\r\n        directiveName,\r\n        directiveArgs,\r\n        hasDirectives = false,\r\n        ch;\r\n\r\n    state.version = null;\r\n    state.checkLineBreaks = state.legacy;\r\n    state.tagMap = Object.create(null);\r\n    state.anchorMap = Object.create(null);\r\n\r\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\r\n        skipSeparationSpace(state, true, -1);\r\n\r\n        ch = state.input.charCodeAt(state.position);\r\n\r\n        if (state.lineIndent > 0 || ch !== 0x25/* % */) {\r\n            break;\r\n        }\r\n\r\n        hasDirectives = true;\r\n        ch = state.input.charCodeAt(++state.position);\r\n        _position = state.position;\r\n\r\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\r\n            ch = state.input.charCodeAt(++state.position);\r\n        }\r\n\r\n        directiveName = state.input.slice(_position, state.position);\r\n        directiveArgs = [];\r\n\r\n        if (directiveName.length < 1) {\r\n            throwError(state, 'directive name must not be less than one character in length');\r\n        }\r\n\r\n        while (ch !== 0) {\r\n            while (is_WHITE_SPACE(ch)) {\r\n                ch = state.input.charCodeAt(++state.position);\r\n            }\r\n\r\n            if (ch === 0x23/* # */) {\r\n                do {\r\n                    ch = state.input.charCodeAt(++state.position);\r\n                }\r\n                while (ch !== 0 && !is_EOL(ch));\r\n                break;\r\n            }\r\n\r\n            if (is_EOL(ch)) {\r\n                break;\r\n            }\r\n\r\n            _position = state.position;\r\n\r\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\r\n                ch = state.input.charCodeAt(++state.position);\r\n            }\r\n\r\n            directiveArgs.push(state.input.slice(_position, state.position));\r\n        }\r\n\r\n        if (ch !== 0) {\r\n            readLineBreak(state);\r\n        }\r\n\r\n        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\r\n            directiveHandlers[directiveName](state, directiveName, directiveArgs);\r\n        } else {\r\n            throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\r\n        }\r\n    }\r\n\r\n    skipSeparationSpace(state, true, -1);\r\n\r\n    if (state.lineIndent === 0 &&\r\n        state.input.charCodeAt(state.position) === 0x2D/* - */ &&\r\n        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\r\n        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\r\n        state.position += 3;\r\n        skipSeparationSpace(state, true, -1);\r\n\r\n    } else if (hasDirectives) {\r\n        throwError(state, 'directives end mark is expected');\r\n    }\r\n\r\n    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\r\n    skipSeparationSpace(state, true, -1);\r\n\r\n    if (state.checkLineBreaks &&\r\n        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\r\n        throwWarning(state, 'non-ASCII line breaks are interpreted as content');\r\n    }\r\n\r\n    state.documents.push(state.result);\r\n\r\n    if (state.position === state.lineStart && testDocumentSeparator(state)) {\r\n\r\n        if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\r\n            state.position += 3;\r\n            skipSeparationSpace(state, true, -1);\r\n        }\r\n        return;\r\n    }\r\n\r\n    if (state.position < (state.length - 1)) {\r\n        throwError(state, 'end of the stream or a document separator is expected');\r\n    } else {\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param input\r\n * @param options\r\n */\r\nfunction loadDocuments(input, options) {\r\n    input = String(input);\r\n    options = options || {};\r\n\r\n    if (input.length !== 0) {\r\n\r\n        // Add tailing `\\n` if not exists\r\n        if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\r\n            input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\r\n            input += '\\n';\r\n        }\r\n\r\n        // Strip BOM\r\n        if (input.charCodeAt(0) === 0xFEFF) {\r\n            input = input.slice(1);\r\n        }\r\n    }\r\n\r\n    let state = new State$1(input, options);\r\n\r\n    let nullpos = input.indexOf('\\0');\r\n\r\n    if (nullpos !== -1) {\r\n        state.position = nullpos;\r\n        throwError(state, 'null byte is not allowed in input');\r\n    }\r\n\r\n    // Use 0 as string terminator. That significantly simplifies bounds check.\r\n    state.input += '\\0';\r\n\r\n    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\r\n        state.lineIndent += 1;\r\n        state.position += 1;\r\n    }\r\n\r\n    while (state.position < (state.length - 1)) {\r\n        readDocument(state);\r\n    }\r\n\r\n    return state.documents;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param input\r\n * @param iterator\r\n * @param options\r\n */\r\nfunction loadAll$1(input, iterator, options) {\r\n    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\r\n        options = iterator;\r\n        iterator = null;\r\n    }\r\n\r\n    let documents = loadDocuments(input, options);\r\n\r\n    if (typeof iterator !== 'function') {\r\n        return documents;\r\n    }\r\n\r\n    for (let index = 0, length = documents.length; index < length; index += 1) {\r\n        iterator(documents[index]);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {string} input\r\n * @param {Object?} options\r\n */\r\nfunction load$1(input, options) {\r\n    let documents = loadDocuments(input, options);\r\n\r\n    if (documents.length === 0) {\r\n\r\n        return undefined;\r\n    } else if (documents.length === 1) {\r\n        return documents[0];\r\n    }\r\n    throw new exception('expected a single document in the stream, but found more');\r\n}\r\n\r\n\r\nlet loadAll_1 = loadAll$1;\r\nlet load_1 = load$1;\r\n\r\nlet loader = {\r\n    loadAll: loadAll_1,\r\n    load: load_1\r\n};\r\n\r\n\r\nlet _toString = Object.prototype.toString;\r\nlet _hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nlet CHAR_BOM = 0xFEFF;\r\nlet CHAR_TAB = 0x09; /* Tab */\r\nlet CHAR_LINE_FEED = 0x0A; /* LF */\r\nlet CHAR_CARRIAGE_RETURN = 0x0D; /* CR */\r\nlet CHAR_SPACE = 0x20; /* Space */\r\nlet CHAR_EXCLAMATION = 0x21; /* ! */\r\nlet CHAR_DOUBLE_QUOTE = 0x22; /* \" */\r\nlet CHAR_SHARP = 0x23; /* # */\r\nlet CHAR_PERCENT = 0x25; /* % */\r\nlet CHAR_AMPERSAND = 0x26; /* & */\r\nlet CHAR_SINGLE_QUOTE = 0x27; /* ' */\r\nlet CHAR_ASTERISK = 0x2A; /* * */\r\nlet CHAR_COMMA = 0x2C; /* , */\r\nlet CHAR_MINUS = 0x2D; /* - */\r\nlet CHAR_COLON = 0x3A; /* : */\r\nlet CHAR_EQUALS = 0x3D; /* = */\r\nlet CHAR_GREATER_THAN = 0x3E; /* > */\r\nlet CHAR_QUESTION = 0x3F; /* ? */\r\nlet CHAR_COMMERCIAL_AT = 0x40; /* @ */\r\nlet CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */\r\nlet CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\r\nlet CHAR_GRAVE_ACCENT = 0x60; /* ` */\r\nlet CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */\r\nlet CHAR_VERTICAL_LINE = 0x7C; /* | */\r\nlet CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */\r\n\r\nlet ESCAPE_SEQUENCES = {};\r\n\r\nESCAPE_SEQUENCES[0x00] = '\\\\0';\r\nESCAPE_SEQUENCES[0x07] = '\\\\a';\r\nESCAPE_SEQUENCES[0x08] = '\\\\b';\r\nESCAPE_SEQUENCES[0x09] = '\\\\t';\r\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\r\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\r\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\r\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\r\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\r\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\r\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\r\nESCAPE_SEQUENCES[0x85] = '\\\\N';\r\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\r\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\r\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\r\n\r\nlet DEPRECATED_BOOLEANS_SYNTAX = [\r\n    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\r\n    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\r\n];\r\n\r\nlet DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\r\n\r\n/**\r\n *\r\n * @param schema\r\n * @param map\r\n */\r\nfunction compileStyleMap(schema, map) {\r\n    let result, keys, index, length, tag, style, type;\r\n\r\n    if (map === null) {\r\n        return {};\r\n    }\r\n\r\n    result = {};\r\n    keys = Object.keys(map);\r\n\r\n    for (index = 0, length = keys.length; index < length; index += 1) {\r\n        tag = keys[index];\r\n        style = String(map[tag]);\r\n\r\n        if (tag.slice(0, 2) === '!!') {\r\n            tag = 'tag:yaml.org,2002:' + tag.slice(2);\r\n        }\r\n        type = schema.compiledTypeMap.fallback[tag];\r\n\r\n        if (type && _hasOwnProperty.call(type.styleAliases, style)) {\r\n            style = type.styleAliases[style];\r\n        }\r\n\r\n        result[tag] = style;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n *\r\n * @param character\r\n */\r\nfunction encodeHex(character) {\r\n    let string, handle, length;\r\n\r\n    string = character.toString(16).toUpperCase();\r\n\r\n    if (character <= 0xFF) {\r\n        handle = 'x';\r\n        length = 2;\r\n    } else if (character <= 0xFFFF) {\r\n        handle = 'u';\r\n        length = 4;\r\n    } else if (character <= 0xFFFFFFFF) {\r\n        handle = 'U';\r\n        length = 8;\r\n    } else {\r\n        throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\r\n    }\r\n\r\n    return '\\\\' + handle + common.repeat('0', length - string.length) + string;\r\n}\r\n\r\n\r\nlet QUOTING_TYPE_SINGLE = 1,\r\n    QUOTING_TYPE_DOUBLE = 2;\r\n\r\n/**\r\n *\r\n * @param options\r\n */\r\nfunction State(options) {\r\n    this.schema = options.schema || _default;\r\n    this.indent = Math.max(1, (options.indent || 2));\r\n    this.noArrayIndent = options.noArrayIndent || false;\r\n    this.skipInvalid = options.skipInvalid || false;\r\n    this.flowLevel = (common.isNothing(options.flowLevel) ? -1 : options.flowLevel);\r\n    this.styleMap = compileStyleMap(this.schema, options.styles || null);\r\n    this.sortKeys = options.sortKeys || false;\r\n    this.lineWidth = options.lineWidth || 80;\r\n    this.noRefs = options.noRefs || false;\r\n    this.noCompatMode = options.noCompatMode || false;\r\n    this.condenseFlow = options.condenseFlow || false;\r\n    this.quotingType = options.quotingType === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\r\n    this.forceQuotes = options.forceQuotes || false;\r\n    this.replacer = typeof options.replacer === 'function' ? options.replacer : null;\r\n\r\n    this.implicitTypes = this.schema.compiledImplicit;\r\n    this.explicitTypes = this.schema.compiledExplicit;\r\n\r\n    this.tag = null;\r\n    this.result = '';\r\n\r\n    this.duplicates = [];\r\n    this.usedDuplicates = null;\r\n}\r\n\r\n// Indents every line in a string. Empty lines (\\n only) are not indented.\r\n/**\r\n *\r\n * @param string\r\n * @param spaces\r\n */\r\nfunction indentString(string, spaces) {\r\n    let ind = common.repeat(' ', spaces),\r\n        position = 0,\r\n        next = -1,\r\n        result = '',\r\n        line,\r\n        length = string.length;\r\n\r\n    while (position < length) {\r\n        next = string.indexOf('\\n', position);\r\n        if (next === -1) {\r\n            line = string.slice(position);\r\n            position = length;\r\n        } else {\r\n            line = string.slice(position, next + 1);\r\n            position = next + 1;\r\n        }\r\n\r\n        if (line.length && line !== '\\n') {\r\n            result += ind;\r\n        }\r\n\r\n        result += line;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param level\r\n */\r\nfunction generateNextLine(state, level) {\r\n    return '\\n' + common.repeat(' ', state.indent * level);\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param str\r\n */\r\nfunction testImplicitResolving(state, str) {\r\n    let index, length, type;\r\n\r\n    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\r\n        type = state.implicitTypes[index];\r\n\r\n        if (type.resolve(str)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// [33] s-white ::= s-space | s-tab\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction isWhitespace(c) {\r\n    return c === CHAR_SPACE || c === CHAR_TAB;\r\n}\r\n\r\n// Returns true if the character can be printed without escaping.\r\n// From YAML 1.2: \"any allowed characters known to be non-printable\r\n// should also be escaped. [However,] This isn’t mandatory\"\r\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction isPrintable(c) {\r\n    return (0x00020 <= c && c <= 0x00007E)\r\n        || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\r\n        || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\r\n        || (0x10000 <= c && c <= 0x10FFFF);\r\n}\r\n\r\n// [34] ns-char ::= nb-char - s-white\r\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\r\n// [26] b-char  ::= b-line-feed | b-carriage-return\r\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\r\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction isNsCharOrWhitespace(c) {\r\n    return isPrintable(c)\r\n        && c !== CHAR_BOM\r\n        // - b-char\r\n        && c !== CHAR_CARRIAGE_RETURN\r\n        && c !== CHAR_LINE_FEED;\r\n}\r\n\r\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\r\n//                             c = flow-in   ⇒ ns-plain-safe-in\r\n//                             c = block-key ⇒ ns-plain-safe-out\r\n//                             c = flow-key  ⇒ ns-plain-safe-in\r\n// [128] ns-plain-safe-out ::= ns-char\r\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\r\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\r\n//                            | ( /* An ns-char preceding */ “#” )\r\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\r\n/**\r\n *\r\n * @param c\r\n * @param prev\r\n * @param inblock\r\n */\r\nfunction isPlainSafe(c, prev, inblock) {\r\n    let cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\r\n    let cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\r\n    return (\r\n        // Ns-plain-safe\r\n        inblock ? // C = flow-in\r\n            cIsNsCharOrWhitespace\r\n            : cIsNsCharOrWhitespace\r\n            // - c-flow-indicator\r\n            && c !== CHAR_COMMA\r\n            && c !== CHAR_LEFT_SQUARE_BRACKET\r\n            && c !== CHAR_RIGHT_SQUARE_BRACKET\r\n            && c !== CHAR_LEFT_CURLY_BRACKET\r\n            && c !== CHAR_RIGHT_CURLY_BRACKET\r\n    )\r\n        // Ns-plain-char\r\n        && c !== CHAR_SHARP // False on '#'\r\n        && !(prev === CHAR_COLON && !cIsNsChar) // False on ': '\r\n        || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // Change to true on '[^ ]#'\r\n        || (prev === CHAR_COLON && cIsNsChar); // Change to true on ':[^ ]'\r\n}\r\n\r\n// Simplified test for values allowed as the first character in plain style.\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction isPlainSafeFirst(c) {\r\n    // Uses a subset of ns-char - c-indicator\r\n    // where ns-char = nb-char - s-white.\r\n    // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\r\n    return isPrintable(c) && c !== CHAR_BOM\r\n        && !isWhitespace(c) // - s-white\r\n        // - (c-indicator ::=\r\n        // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\r\n        && c !== CHAR_MINUS\r\n        && c !== CHAR_QUESTION\r\n        && c !== CHAR_COLON\r\n        && c !== CHAR_COMMA\r\n        && c !== CHAR_LEFT_SQUARE_BRACKET\r\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\r\n        && c !== CHAR_LEFT_CURLY_BRACKET\r\n        && c !== CHAR_RIGHT_CURLY_BRACKET\r\n        // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\r\n        && c !== CHAR_SHARP\r\n        && c !== CHAR_AMPERSAND\r\n        && c !== CHAR_ASTERISK\r\n        && c !== CHAR_EXCLAMATION\r\n        && c !== CHAR_VERTICAL_LINE\r\n        && c !== CHAR_EQUALS\r\n        && c !== CHAR_GREATER_THAN\r\n        && c !== CHAR_SINGLE_QUOTE\r\n        && c !== CHAR_DOUBLE_QUOTE\r\n        // | “%” | “@” | “`”)\r\n        && c !== CHAR_PERCENT\r\n        && c !== CHAR_COMMERCIAL_AT\r\n        && c !== CHAR_GRAVE_ACCENT;\r\n}\r\n\r\n// Simplified test for values allowed as the last character in plain style.\r\n/**\r\n *\r\n * @param c\r\n */\r\nfunction isPlainSafeLast(c) {\r\n    // Just not whitespace or colon, it will be checked to be plain character later\r\n    return !isWhitespace(c) && c !== CHAR_COLON;\r\n}\r\n\r\n// Same as 'string'.codePointAt(pos), but works in older browsers.\r\n/**\r\n *\r\n * @param string\r\n * @param pos\r\n */\r\nfunction codePointAt(string, pos) {\r\n    let first = string.charCodeAt(pos),\r\n        second;\r\n    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\r\n        second = string.charCodeAt(pos + 1);\r\n        if (second >= 0xDC00 && second <= 0xDFFF) {\r\n            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\r\n            return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\r\n        }\r\n    }\r\n    return first;\r\n}\r\n\r\n// Determines whether block indentation indicator is required.\r\n/**\r\n *\r\n * @param string\r\n */\r\nfunction needIndentIndicator(string) {\r\n    let leadingSpaceRe = /^\\n* /;\r\n    return leadingSpaceRe.test(string);\r\n}\r\n\r\nlet STYLE_PLAIN = 1,\r\n    STYLE_SINGLE = 2,\r\n    STYLE_LITERAL = 3,\r\n    STYLE_FOLDED = 4,\r\n    STYLE_DOUBLE = 5;\r\n\r\n// Determines which scalar styles are possible and returns the preferred style.\r\n// lineWidth = -1 => no limit.\r\n// Pre-conditions: str.length > 0.\r\n// Post-conditions:\r\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\r\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\r\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\r\n/**\r\n *\r\n * @param string\r\n * @param singleLineOnly\r\n * @param indentPerLevel\r\n * @param lineWidth\r\n * @param testAmbiguousType\r\n * @param quotingType\r\n * @param forceQuotes\r\n * @param inblock\r\n */\r\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\r\n    testAmbiguousType, quotingType, forceQuotes, inblock) {\r\n\r\n    let i;\r\n    let char = 0;\r\n    let prevChar = null;\r\n    let hasLineBreak = false;\r\n    let hasFoldableLine = false; // Only checked if shouldTrackWidth\r\n    let shouldTrackWidth = lineWidth !== -1;\r\n    let previousLineBreak = -1; // Count the first line correctly\r\n    let plain = isPlainSafeFirst(codePointAt(string, 0))\r\n        && isPlainSafeLast(codePointAt(string, string.length - 1));\r\n\r\n    if (singleLineOnly || forceQuotes) {\r\n        // Case: no block styles.\r\n        // Check for disallowed characters to rule out plain and single.\r\n        for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\r\n            char = codePointAt(string, i);\r\n            if (!isPrintable(char)) {\r\n                return STYLE_DOUBLE;\r\n            }\r\n            plain = plain && isPlainSafe(char, prevChar, inblock);\r\n            prevChar = char;\r\n        }\r\n    } else {\r\n        // Case: block styles permitted.\r\n        for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\r\n            char = codePointAt(string, i);\r\n            if (char === CHAR_LINE_FEED) {\r\n                hasLineBreak = true;\r\n                // Check if any line can be folded.\r\n                if (shouldTrackWidth) {\r\n                    hasFoldableLine = hasFoldableLine ||\r\n                        // Foldable line = too long, and not more-indented.\r\n                        (i - previousLineBreak - 1 > lineWidth &&\r\n                            string[previousLineBreak + 1] !== ' ');\r\n                    previousLineBreak = i;\r\n                }\r\n            } else if (!isPrintable(char)) {\r\n                return STYLE_DOUBLE;\r\n            }\r\n            plain = plain && isPlainSafe(char, prevChar, inblock);\r\n            prevChar = char;\r\n        }\r\n        // In case the end is missing a \\n\r\n        hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\r\n            (i - previousLineBreak - 1 > lineWidth &&\r\n                string[previousLineBreak + 1] !== ' '));\r\n    }\r\n    // Although every style can represent \\n without escaping, prefer block styles\r\n    // for multiline, since they're more readable and they don't add empty lines.\r\n    // Also prefer folding a super-long line.\r\n    if (!hasLineBreak && !hasFoldableLine) {\r\n        // Strings interpretable as another type have to be quoted;\r\n        // e.g. the string 'true' vs. the boolean true.\r\n        if (plain && !forceQuotes && !testAmbiguousType(string)) {\r\n            return STYLE_PLAIN;\r\n        }\r\n        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\r\n    }\r\n    // Edge case: block indentation indicator can only have one digit.\r\n    if (indentPerLevel > 9 && needIndentIndicator(string)) {\r\n        return STYLE_DOUBLE;\r\n    }\r\n    // At this point we know block styles are valid.\r\n    // Prefer literal style unless we want to fold.\r\n    if (!forceQuotes) {\r\n        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\r\n    }\r\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\r\n}\r\n\r\n// Note: line breaking/folding is implemented for only the folded style.\r\n// NB. We drop the last trailing newline (if any) of a returned block scalar\r\n//  since the dumper adds its own newline. This always works:\r\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\r\n//    • Ending newline    => removed then restored.\r\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\r\n/**\r\n *\r\n * @param state\r\n * @param string\r\n * @param level\r\n * @param iskey\r\n * @param inblock\r\n */\r\nfunction writeScalar(state, string, level, iskey, inblock) {\r\n    state.dump = (function() {\r\n        if (string.length === 0) {\r\n            return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\r\n        }\r\n        if (!state.noCompatMode) {\r\n            if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\r\n                return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\r\n            }\r\n        }\r\n\r\n        let indent = state.indent * Math.max(1, level); // No 0-indent scalars\r\n        // As indentation gets deeper, let the width decrease monotonically\r\n        // to the lower bound min(state.lineWidth, 40).\r\n        // Note that this implies\r\n        //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\r\n        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\r\n        // This behaves better than a constant minimum width which disallows narrower options,\r\n        // or an indent threshold which causes the width to suddenly increase.\r\n        let lineWidth = state.lineWidth === -1\r\n            ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\r\n\r\n        // Without knowing if keys are implicit/explicit, assume implicit for safety.\r\n        let singleLineOnly = iskey\r\n            // No block styles in flow mode.\r\n            || (state.flowLevel > -1 && level >= state.flowLevel);\r\n        /**\r\n         *\r\n         * @param string\r\n         */\r\n        function testAmbiguity(string) {\r\n            return testImplicitResolving(state, string);\r\n        }\r\n\r\n        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\r\n            testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\r\n\r\n            case STYLE_PLAIN:\r\n                return string;\r\n            case STYLE_SINGLE:\r\n                return \"'\" + string.replace(/'/g, \"''\") + \"'\";\r\n            case STYLE_LITERAL:\r\n                return '|' + blockHeader(string, state.indent)\r\n                    + dropEndingNewline(indentString(string, indent));\r\n            case STYLE_FOLDED:\r\n                return '>' + blockHeader(string, state.indent)\r\n                    + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\r\n            case STYLE_DOUBLE:\r\n                return '\"' + escapeString(string) + '\"';\r\n            default:\r\n                throw new exception('impossible error: invalid scalar style');\r\n        }\r\n    }());\r\n}\r\n\r\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\r\n/**\r\n *\r\n * @param string\r\n * @param indentPerLevel\r\n */\r\nfunction blockHeader(string, indentPerLevel) {\r\n    let indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\r\n\r\n    // Note the special case: the string '\\n' counts as a \"trailing\" empty line.\r\n    let clip = string[string.length - 1] === '\\n';\r\n    let keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\r\n    let chomp = keep ? '+' : (clip ? '' : '-');\r\n\r\n    return indentIndicator + chomp + '\\n';\r\n}\r\n\r\n// (See the note for writeScalar.)\r\n/**\r\n *\r\n * @param string\r\n */\r\nfunction dropEndingNewline(string) {\r\n    return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\r\n}\r\n\r\n// Note: a long line without a suitable break point will exceed the width limit.\r\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\r\n/**\r\n *\r\n * @param string\r\n * @param width\r\n */\r\nfunction foldString(string, width) {\r\n    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\r\n    // unless they're before or after a more-indented line, or at the very\r\n    // beginning or end, in which case $k$ maps to $k$.\r\n    // Therefore, parse each chunk as newline(s) followed by a content line.\r\n    let lineRe = /(\\n+)([^\\n]*)/g;\r\n\r\n    // First line (possibly an empty line)\r\n    let result = (function() {\r\n        let nextLF = string.indexOf('\\n');\r\n        nextLF = nextLF !== -1 ? nextLF : string.length;\r\n        lineRe.lastIndex = nextLF;\r\n        return foldLine(string.slice(0, nextLF), width);\r\n    }());\r\n    // If we haven't reached the first content line yet, don't add an extra \\n.\r\n    let prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\r\n    let moreIndented;\r\n\r\n    // Rest of the lines\r\n    let match;\r\n    while ((match = lineRe.exec(string))) {\r\n        let prefix = match[1],\r\n            line = match[2];\r\n        moreIndented = (line[0] === ' ');\r\n        result += prefix\r\n            + (!prevMoreIndented && !moreIndented && line !== ''\r\n                ? '\\n' : '')\r\n            + foldLine(line, width);\r\n        prevMoreIndented = moreIndented;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// Greedy line breaking.\r\n// Picks the longest line under the limit each time,\r\n// otherwise settles for the shortest line over the limit.\r\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\r\n/**\r\n *\r\n * @param line\r\n * @param width\r\n */\r\nfunction foldLine(line, width) {\r\n    if (line === '' || line[0] === ' ') {\r\n        return line;\r\n    }\r\n\r\n    // Since a more-indented line adds a \\n, breaks can't be followed by a space.\r\n    let breakRe = / [^ ]/g; // Note: the match index will always be <= length-2.\r\n    let match;\r\n    // Start is an inclusive index. end, curr, and next are exclusive.\r\n    let start = 0,\r\n        end,\r\n        curr = 0,\r\n        next = 0;\r\n    let result = '';\r\n\r\n    // Invariants: 0 <= start <= length-1.\r\n    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\r\n    // Inside the loop:\r\n    //   A match implies length >= 2, so curr and next are <= length-2.\r\n    while ((match = breakRe.exec(line))) {\r\n        next = match.index;\r\n        // Maintain invariant: curr - start <= width\r\n        if (next - start > width) {\r\n            end = (curr > start) ? curr : next; // Derive end <= length-2\r\n            result += '\\n' + line.slice(start, end);\r\n            // Skip the space that was output as \\n\r\n            start = end + 1; // Derive start <= length-1\r\n        }\r\n        curr = next;\r\n    }\r\n\r\n    // By the invariants, start <= length-1, so there is something left over.\r\n    // It is either the whole string or a part starting from non-whitespace.\r\n    result += '\\n';\r\n    // Insert a break if the remainder is too long and there is a break available.\r\n    if (line.length - start > width && curr > start) {\r\n        result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\r\n    } else {\r\n        result += line.slice(start);\r\n    }\r\n\r\n    return result.slice(1); // Drop extra \\n joiner\r\n}\r\n\r\n// Escapes a double-quoted string.\r\n/**\r\n *\r\n * @param string\r\n */\r\nfunction escapeString(string) {\r\n    let result = '';\r\n    let char = 0;\r\n    let escapeSeq;\r\n\r\n    for (let i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\r\n        char = codePointAt(string, i);\r\n        escapeSeq = ESCAPE_SEQUENCES[char];\r\n\r\n        if (!escapeSeq && isPrintable(char)) {\r\n            result += string[i];\r\n            if (char >= 0x10000) {\r\n                result += string[i + 1];\r\n            }\r\n        } else {\r\n            result += escapeSeq || encodeHex(char);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param level\r\n * @param object\r\n */\r\nfunction writeFlowSequence(state, level, object) {\r\n    let _result = '',\r\n        _tag = state.tag,\r\n        index,\r\n        length,\r\n        value;\r\n\r\n    for (index = 0, length = object.length; index < length; index += 1) {\r\n        value = object[index];\r\n\r\n        if (state.replacer) {\r\n            value = state.replacer.call(object, String(index), value);\r\n        }\r\n\r\n        // Write only valid elements, put null instead of invalid elements.\r\n        if (writeNode(state, level, value, false, false) ||\r\n            (typeof value === 'undefined' &&\r\n                writeNode(state, level, null, false, false))) {\r\n\r\n            if (_result !== '') {\r\n                _result += ',' + (!state.condenseFlow ? ' ' : '');\r\n            }\r\n            _result += state.dump;\r\n        }\r\n    }\r\n\r\n    state.tag = _tag;\r\n    state.dump = '[' + _result + ']';\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param level\r\n * @param object\r\n * @param compact\r\n */\r\nfunction writeBlockSequence(state, level, object, compact) {\r\n    let _result = '',\r\n        _tag = state.tag,\r\n        index,\r\n        length,\r\n        value;\r\n\r\n    for (index = 0, length = object.length; index < length; index += 1) {\r\n        value = object[index];\r\n\r\n        if (state.replacer) {\r\n            value = state.replacer.call(object, String(index), value);\r\n        }\r\n\r\n        // Write only valid elements, put null instead of invalid elements.\r\n        if (writeNode(state, level + 1, value, true, true, false, true) ||\r\n            (typeof value === 'undefined' &&\r\n                writeNode(state, level + 1, null, true, true, false, true))) {\r\n\r\n            if (!compact || _result !== '') {\r\n                _result += generateNextLine(state, level);\r\n            }\r\n\r\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\r\n                _result += '-';\r\n            } else {\r\n                _result += '- ';\r\n            }\r\n\r\n            _result += state.dump;\r\n        }\r\n    }\r\n\r\n    state.tag = _tag;\r\n    state.dump = _result || '[]'; // Empty sequence if no valid values.\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param level\r\n * @param object\r\n */\r\nfunction writeFlowMapping(state, level, object) {\r\n    let _result = '',\r\n        _tag = state.tag,\r\n        objectKeyList = Object.keys(object),\r\n        index,\r\n        length,\r\n        objectKey,\r\n        objectValue,\r\n        pairBuffer;\r\n\r\n    for (index = 0, length = objectKeyList.length; index < length; index += 1) {\r\n\r\n        pairBuffer = '';\r\n        if (_result !== '') {\r\n            pairBuffer += ', ';\r\n        }\r\n\r\n        if (state.condenseFlow) {\r\n            pairBuffer += '\"';\r\n        }\r\n\r\n        objectKey = objectKeyList[index];\r\n        objectValue = object[objectKey];\r\n\r\n        if (state.replacer) {\r\n            objectValue = state.replacer.call(object, objectKey, objectValue);\r\n        }\r\n\r\n        if (!writeNode(state, level, objectKey, false, false)) {\r\n            continue; // Skip this pair because of invalid key;\r\n        }\r\n\r\n        if (state.dump.length > 1024) {\r\n            pairBuffer += '? ';\r\n        }\r\n\r\n        pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\r\n\r\n        if (!writeNode(state, level, objectValue, false, false)) {\r\n            continue; // Skip this pair because of invalid value.\r\n        }\r\n\r\n        pairBuffer += state.dump;\r\n\r\n        // Both key and value are valid.\r\n        _result += pairBuffer;\r\n    }\r\n\r\n    state.tag = _tag;\r\n    state.dump = '{' + _result + '}';\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param level\r\n * @param object\r\n * @param compact\r\n */\r\nfunction writeBlockMapping(state, level, object, compact) {\r\n    let _result = '',\r\n        _tag = state.tag,\r\n        objectKeyList = Object.keys(object),\r\n        index,\r\n        length,\r\n        objectKey,\r\n        objectValue,\r\n        explicitPair,\r\n        pairBuffer;\r\n\r\n    // Allow sorting keys so that the output file is deterministic\r\n    if (state.sortKeys === true) {\r\n        // Default sorting\r\n        objectKeyList.sort();\r\n    } else if (typeof state.sortKeys === 'function') {\r\n        // Custom sort function\r\n        objectKeyList.sort(state.sortKeys);\r\n    } else if (state.sortKeys) {\r\n        // Something is wrong\r\n        throw new exception('sortKeys must be a boolean or a function');\r\n    }\r\n\r\n    for (index = 0, length = objectKeyList.length; index < length; index += 1) {\r\n        pairBuffer = '';\r\n\r\n        if (!compact || _result !== '') {\r\n            pairBuffer += generateNextLine(state, level);\r\n        }\r\n\r\n        objectKey = objectKeyList[index];\r\n        objectValue = object[objectKey];\r\n\r\n        if (state.replacer) {\r\n            objectValue = state.replacer.call(object, objectKey, objectValue);\r\n        }\r\n\r\n        if (!writeNode(state, level + 1, objectKey, true, true, true)) {\r\n            continue; // Skip this pair because of invalid key.\r\n        }\r\n\r\n        explicitPair = (state.tag !== null && state.tag !== '?') ||\r\n            (state.dump && state.dump.length > 1024);\r\n\r\n        if (explicitPair) {\r\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\r\n                pairBuffer += '?';\r\n            } else {\r\n                pairBuffer += '? ';\r\n            }\r\n        }\r\n\r\n        pairBuffer += state.dump;\r\n\r\n        if (explicitPair) {\r\n            pairBuffer += generateNextLine(state, level);\r\n        }\r\n\r\n        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\r\n            continue; // Skip this pair because of invalid value.\r\n        }\r\n\r\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\r\n            pairBuffer += ':';\r\n        } else {\r\n            pairBuffer += ': ';\r\n        }\r\n\r\n        pairBuffer += state.dump;\r\n\r\n        // Both key and value are valid.\r\n        _result += pairBuffer;\r\n    }\r\n\r\n    state.tag = _tag;\r\n    state.dump = _result || '{}'; // Empty mapping if no valid pairs.\r\n}\r\n\r\n/**\r\n *\r\n * @param state\r\n * @param object\r\n * @param explicit\r\n */\r\nfunction detectType(state, object, explicit) {\r\n    let _result, typeList, index, length, type, style;\r\n\r\n    typeList = explicit ? state.explicitTypes : state.implicitTypes;\r\n\r\n    for (index = 0, length = typeList.length; index < length; index += 1) {\r\n        type = typeList[index];\r\n\r\n        if ((type.instanceOf || type.predicate) &&\r\n            (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\r\n            (!type.predicate || type.predicate(object))) {\r\n\r\n            if (explicit) {\r\n                if (type.multi && type.representName) {\r\n                    state.tag = type.representName(object);\r\n                } else {\r\n                    state.tag = type.tag;\r\n                }\r\n            } else {\r\n                state.tag = '?';\r\n            }\r\n\r\n            if (type.represent) {\r\n                style = state.styleMap[type.tag] || type.defaultStyle;\r\n\r\n                if (_toString.call(type.represent) === '[object Function]') {\r\n                    _result = type.represent(object, style);\r\n                } else if (_hasOwnProperty.call(type.represent, style)) {\r\n                    _result = type.represent[style](object, style);\r\n                } else {\r\n                    throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\r\n                }\r\n\r\n                state.dump = _result;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Serializes `object` and writes it to global `result`.\r\n// Returns true on success, or false on invalid object.\r\n//\r\n/**\r\n *\r\n * @param state\r\n * @param level\r\n * @param object\r\n * @param block\r\n * @param compact\r\n * @param iskey\r\n * @param isblockseq\r\n */\r\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\r\n    state.tag = null;\r\n    state.dump = object;\r\n\r\n    if (!detectType(state, object, false)) {\r\n        detectType(state, object, true);\r\n    }\r\n\r\n    let type = _toString.call(state.dump);\r\n    let inblock = block;\r\n    let tagStr;\r\n\r\n    if (block) {\r\n        block = (state.flowLevel < 0 || state.flowLevel > level);\r\n    }\r\n\r\n    let objectOrArray = type === '[object Object]' || type === '[object Array]',\r\n        duplicateIndex,\r\n        duplicate;\r\n\r\n    if (objectOrArray) {\r\n        duplicateIndex = state.duplicates.indexOf(object);\r\n        duplicate = duplicateIndex !== -1;\r\n    }\r\n\r\n    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\r\n        compact = false;\r\n    }\r\n\r\n    if (duplicate && state.usedDuplicates[duplicateIndex]) {\r\n        state.dump = '*ref_' + duplicateIndex;\r\n    } else {\r\n        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\r\n            state.usedDuplicates[duplicateIndex] = true;\r\n        }\r\n        if (type === '[object Object]') {\r\n            if (block && (Object.keys(state.dump).length !== 0)) {\r\n                writeBlockMapping(state, level, state.dump, compact);\r\n                if (duplicate) {\r\n                    state.dump = '&ref_' + duplicateIndex + state.dump;\r\n                }\r\n            } else {\r\n                writeFlowMapping(state, level, state.dump);\r\n                if (duplicate) {\r\n                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\r\n                }\r\n            }\r\n        } else if (type === '[object Array]') {\r\n            if (block && (state.dump.length !== 0)) {\r\n                if (state.noArrayIndent && !isblockseq && level > 0) {\r\n                    writeBlockSequence(state, level - 1, state.dump, compact);\r\n                } else {\r\n                    writeBlockSequence(state, level, state.dump, compact);\r\n                }\r\n                if (duplicate) {\r\n                    state.dump = '&ref_' + duplicateIndex + state.dump;\r\n                }\r\n            } else {\r\n                writeFlowSequence(state, level, state.dump);\r\n                if (duplicate) {\r\n                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\r\n                }\r\n            }\r\n        } else if (type === '[object String]') {\r\n            if (state.tag !== '?') {\r\n                writeScalar(state, state.dump, level, iskey, inblock);\r\n            }\r\n        } else if (type === '[object Undefined]') {\r\n            return false;\r\n        } else {\r\n            if (state.skipInvalid) {\r\n                return false;\r\n            }\r\n            throw new exception('unacceptable kind of an object to dump ' + type);\r\n        }\r\n\r\n        if (state.tag !== null && state.tag !== '?') {\r\n            // Need to encode all characters except those allowed by the spec:\r\n            //\r\n            // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\r\n            // [36] ns-hex-digit    ::=  ns-dec-digit\r\n            //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\r\n            // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\r\n            // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\r\n            // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\r\n            //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\r\n            //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\r\n            //\r\n            // Also need to encode '!' because it has special meaning (end of tag prefix).\r\n            //\r\n            tagStr = encodeURI(\r\n                state.tag[0] === '!' ? state.tag.slice(1) : state.tag\r\n            ).replace(/!/g, '%21');\r\n\r\n            if (state.tag[0] === '!') {\r\n                tagStr = '!' + tagStr;\r\n            } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\r\n                tagStr = '!!' + tagStr.slice(18);\r\n            } else {\r\n                tagStr = '!<' + tagStr + '>';\r\n            }\r\n\r\n            state.dump = tagStr + ' ' + state.dump;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param object\r\n * @param state\r\n */\r\nfunction getDuplicateReferences(object, state) {\r\n    let objects = [],\r\n        duplicatesIndexes = [],\r\n        index,\r\n        length;\r\n\r\n    inspectNode(object, objects, duplicatesIndexes);\r\n\r\n    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\r\n        state.duplicates.push(objects[duplicatesIndexes[index]]);\r\n    }\r\n    state.usedDuplicates = new Array(length);\r\n}\r\n\r\n/**\r\n *\r\n * @param object\r\n * @param objects\r\n * @param duplicatesIndexes\r\n */\r\nfunction inspectNode(object, objects, duplicatesIndexes) {\r\n    let objectKeyList,\r\n        index,\r\n        length;\r\n\r\n    if (object !== null && typeof object === 'object') {\r\n        index = objects.indexOf(object);\r\n        if (index !== -1) {\r\n            if (duplicatesIndexes.indexOf(index) === -1) {\r\n                duplicatesIndexes.push(index);\r\n            }\r\n        } else {\r\n            objects.push(object);\r\n\r\n            if (Array.isArray(object)) {\r\n                for (index = 0, length = object.length; index < length; index += 1) {\r\n                    inspectNode(object[index], objects, duplicatesIndexes);\r\n                }\r\n            } else {\r\n                objectKeyList = Object.keys(object);\r\n\r\n                for (index = 0, length = objectKeyList.length; index < length; index += 1) {\r\n                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param input\r\n * @param options\r\n */\r\nfunction dump$1(input, options) {\r\n    options = options || {};\r\n\r\n    let state = new State(options);\r\n\r\n    if (!state.noRefs) {\r\n        getDuplicateReferences(input, state);\r\n    }\r\n\r\n    let value = input;\r\n\r\n    if (state.replacer) {\r\n        value = state.replacer.call({'': value}, '', value);\r\n    }\r\n\r\n    if (writeNode(state, 0, value, true, true)) {\r\n        return state.dump + '\\n';\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\nlet dump_1 = dump$1;\r\n\r\nlet dumper = {\r\n    dump: dump_1\r\n};\r\n\r\n/**\r\n *\r\n * @param from\r\n * @param to\r\n */\r\nfunction renamed(from, to) {\r\n    return function() {\r\n        throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\r\n            'Use yaml.' + to + ' instead, which is now safe by default.');\r\n    };\r\n}\r\n\r\n\r\nconst Type = type;\r\nconst Schema = schema;\r\nconst FAILSAFE_SCHEMA = failsafe;\r\nconst JSON_SCHEMA = json;\r\nconst CORE_SCHEMA = core;\r\nconst DEFAULT_SCHEMA = _default;\r\nconst load = loader.load;\r\nconst loadAll = loader.loadAll;\r\nconst dump = dumper.dump;\r\nconst YAMLException = exception;\r\n\r\n// Re-export all types in case user wants to create custom schema\r\nconst types = {\r\n    binary: binary,\r\n    \"float\": float,\r\n    map: map,\r\n    \"null\": _null,\r\n    pairs: pairs,\r\n    set: set,\r\n    timestamp: timestamp,\r\n    bool: bool,\r\n    \"int\": int,\r\n    merge: merge,\r\n    omap: omap,\r\n    seq: seq,\r\n    str: str\r\n};\r\n\r\n// Removed functions from JS-YAML 3.0.x\r\nconst safeLoad = renamed('safeLoad', 'load');\r\nconst safeLoadAll = renamed('safeLoadAll', 'loadAll');\r\nconst safeDump = renamed('safeDump', 'dump');\r\n\r\nconst jsYaml = {\r\n    Type: Type,\r\n    Schema: Schema,\r\n    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\r\n    JSON_SCHEMA: JSON_SCHEMA,\r\n    CORE_SCHEMA: CORE_SCHEMA,\r\n    DEFAULT_SCHEMA: DEFAULT_SCHEMA,\r\n    load: load,\r\n    loadAll: loadAll,\r\n    dump: dump,\r\n    YAMLException: YAMLException,\r\n    types: types,\r\n    safeLoad: safeLoad,\r\n    safeLoadAll: safeLoadAll,\r\n    safeDump: safeDump\r\n};\r\n\r\nexport default jsYaml;\r\nexport {CORE_SCHEMA, DEFAULT_SCHEMA, FAILSAFE_SCHEMA, JSON_SCHEMA, Schema, Type, YAMLException, dump, load, loadAll, safeDump, safeLoad, safeLoadAll, types};"],"names":["isNothing","subject","common","isObject","toArray","sequence","Array","isArray","repeat","string","count","cycle","result","isNegativeZero","number","Number","NEGATIVE_INFINITY","extend","target","source","index","length","key","sourceKeys","Object","keys","formatError","exception","compact","where","message","reason","mark","name","line","column","widget","YAMLException$1","Error","call","this","captureStackTrace","constructor","stack","prototype","create","toString","getLine","buffer","lineStart","lineEnd","position","maxLineLength","head","tail","maxHalfLength","Math","floor","str","slice","replace","pos","padStart","max","options","maxLength","indent","linesBefore","linesAfter","match","re","lineStarts","lineEnds","foundLineNo","exec","push","i","lineNoLength","min","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","type","tag","forEach","indexOf","kind","resolve","construct","data","instanceOf","predicate","represent","representName","defaultStyle","multi","styleAliases","map","style","alias","String","compileStyleAliases","compileList","schema","currentType","newIndex","previousType","previousIndex","Schema$1","definition","implicit","explicit","concat","type$1","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","scalar","mapping","fallback","collectType","arguments","compileMap","seq","failsafe","_null","object","canonical","lowercase","uppercase","camelcase","empty","bool","isOctCode","c","isDecCode","int","ch","hasDigits","charCodeAt","value","sign","parseInt","binary","obj","octal","decimal","hexadecimal","toUpperCase","YAML_FLOAT_PATTERN","RegExp","SCIENTIFIC_WITHOUT_DOT","float","test","toLowerCase","POSITIVE_INFINITY","NaN","parseFloat","res","isNaN","json","core","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","timestamp","year","month","day","hour","minute","second","tz_hour","tz_minute","date","fraction","delta","Date","UTC","setTime","getTime","toISOString","merge","BASE64_MAP","code","idx","bitlen","charAt","tailbits","input","bits","Uint8Array","_hasOwnProperty$3","hasOwnProperty","_toString$2","omap","pair","pairKey","pairHasKey","objectKeys","_toString$1","pairs","_hasOwnProperty$2","set","_default","_hasOwnProperty$1","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","State$1","filename","onWarning","legacy","listener","implicitTypes","typeMap","lineIndent","firstTabInLine","documents","generateError","state","throwError","throwWarning","directiveHandlers","YAML","args","major","minor","version","checkLineBreaks","TAG","handle","prefix","tagMap","decodeURIComponent","err","captureSegment","start","end","checkJson","_position","_length","_character","_result","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLine","startLineStart","startPos","defineProperty","configurable","enumerable","writable","readLineBreak","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readBlockSequence","nodeIndent","_line","following","_tag","_anchor","anchor","detected","anchorMap","composeNode","readTagProperty","tagHandle","tagName","isVerbatim","isNamed","readAnchorProperty","parentIndent","nodeContext","allowToSeek","allowCompact","allowBlockStyles","allowBlockScalars","allowBlockCollections","typeIndex","typeQuantity","typeList","flowIndent","blockIndent","indentStatus","atNewLine","hasContent","_keyLine","_keyLineStart","_keyPos","atExplicitKey","readBlockMapping","_lineStart","_pos","terminator","isPair","isExplicitPair","isMapping","readNext","readFlowCollection","captureStart","folding","tmp","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockScalar","captureEnd","readSingleQuotedScalar","hexLength","hexResult","readDoubleQuotedScalar","readAlias","withinFlowCollection","preceding","hasPendingContent","_lineIndent","_kind","readPlainScalar","readDocument","directiveName","directiveArgs","documentStart","hasDirectives","loadDocuments","nullpos","loader","loadAll","iterator","load","_toString","_hasOwnProperty","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","encodeHex","character","State","noArrayIndent","skipInvalid","flowLevel","styleMap","compileStyleMap","styles","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","quotingType","forceQuotes","replacer","explicitTypes","duplicates","usedDuplicates","indentString","spaces","ind","next","generateNextLine","level","isWhitespace","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","codePointAt","first","needIndentIndicator","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","isPlainSafeLast","writeScalar","iskey","dump","testImplicitResolving","blockHeader","dropEndingNewline","width","moreIndented","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","foldString","escapeSeq","escapeString","indentIndicator","clip","breakRe","curr","writeBlockSequence","writeNode","detectType","block","isblockseq","tagStr","duplicateIndex","duplicate","objectOrArray","objectKey","objectValue","explicitPair","pairBuffer","objectKeyList","sort","writeBlockMapping","writeFlowMapping","writeFlowSequence","encodeURI","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","dumper","renamed","from","to","Type","_exports","Schema","FAILSAFE_SCHEMA","JSON_SCHEMA","CORE_SCHEMA","DEFAULT_SCHEMA","YAMLException","types","null","safeLoad","safeLoadAll","safeDump","_default2","default"],"mappings":"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"}