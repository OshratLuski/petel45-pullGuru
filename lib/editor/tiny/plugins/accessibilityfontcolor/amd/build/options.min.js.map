{"version":3,"file":"options.min.js","sources":["../src/options.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Options helper for Tiny Font Color plugin.\n *\n * @module      tiny_accessibilityfontcolor\n * @copyright   2023 Luca BÃ¶sch <luca.boesch@bfh.ch>\n * @copyright   2023 Stephan Robotta <stephan.robotta@bfh.ch>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getPluginOptionName} from 'editor_tiny/options';\nimport {pluginName} from './common';\nimport {isArrayOf, isString, mapColors} from \"./polyfill\";\n\nconst forecolorMap = getPluginOptionName(pluginName, 'textcolors');\nconst backcolorMap = getPluginOptionName(pluginName, 'backgroundcolors');\nconst forecolorPicker = getPluginOptionName(pluginName, 'textcolorpicker');\nconst backcolorPicker = getPluginOptionName(pluginName, 'backgroundcolorpicker');\n\nimport { getAccessibleBackgroundColors, getAccessibleTextColors, rgbToHex, addRemoveColorIfMissing } from './coloraccessibility';\nimport { initializeColorStorage } from './colorstorage';\n\n\n/**\n * Register the options for the Tiny Equation plugin.\n *\n * @param {TinyMCE} editor\n */\nexport const register = (editor) => {\n  editor.options.register(forecolorMap, {\n    processor: value => {\n        // let processedColors;\n\n        // if (isArrayOf(value, isString)) {\n        //     processedColors = mapColors(value);\n        // } else {\n        //     processedColors = value;\n        // }\n\n        // if (!processedColors.some(color => color.value === 'remove')) {\n        //     processedColors.push({\n        //         text: 'Remove Color',\n        //         icon: 'color-swatch-remove-color',\n        //         value: 'remove',\n        //         type: 'choiceitem'\n        //     });\n        // }\n\n        // return {\n        //     value: processedColors,\n        //     valid: true\n        // };\n\n        let processedColors = isArrayOf(value, isString) ? mapColors(value) : value;\n        return {\n            value: addRemoveColorIfMissing(processedColors),\n            valid: true\n        };\n    },\n    \"default\": [],\n  });\n\n  editor.options.register(backcolorMap, {\n    processor: value => {\n      // let processedColors;\n\n      // if (isArrayOf(value, isString)) {\n      //   processedColors = mapColors(value);\n      // } else {\n      //     processedColors = value;\n      // }\n\n      //   if (!processedColors.some(color => color.value === 'remove')) {\n      //     processedColors.push({\n      //       text: 'Remove Color',\n      //       icon: 'color-swatch-remove-color',\n      //       value: 'remove',\n      //       type: 'choiceitem'\n      //     });\n      //   }\n\n      //   return {\n      //     value: processedColors,\n      //     valid: true\n      //   };\n\n      let processedColors = isArrayOf(value, isString) ? mapColors(value) : value;\n        return {\n            value: addRemoveColorIfMissing(processedColors),\n            valid: true\n        };\n      },\n    \"default\": [],\n  });\n\n  setTimeout(() => {\n    initializeColorStorage(editor);\n  }, 500);\n\n  /**\n   * Register event listener in TinyMCE\n   */\n  editor.on('change', function() {\n    let node = editor.selection.getNode();\n\n    let selectedTextColor = rgbToHex(window.getComputedStyle(node).color);\n    let selectedBgColor = rgbToHex(window.getComputedStyle(node).backgroundColor);\n\n    if (selectedTextColor) {\n        let filteredColors = getAccessibleBackgroundColors(selectedTextColor);\n        editor.options.register(backcolorMap, {\n          processor: () => {\n              return {\n                  value: filteredColors,\n                  valid: true\n              };\n          },\n          \"default\": []\n      });\n\n        editor.dispatch('TextColorChange', { name: 'backcolor', color: selectedBgColor });\n    }\n\n    if (selectedBgColor) {\n        let filteredColors = getAccessibleTextColors(selectedBgColor);\n        editor.options.register(forecolorMap, {\n          processor: () => {\n              return {\n                  value: filteredColors,\n                  valid: true\n              };\n          },\n          \"default\": []\n      });\n\n        editor.dispatch('TextColorChange', { name: 'forecolor', color: selectedTextColor });\n    }\n  });\n\n\n  editor.options.register(forecolorPicker, {\n    processor: 'boolean',\n    \"default\": false,\n  });\n\n  editor.options.register(backcolorPicker, {\n    processor: 'boolean',\n    \"default\": false,\n  });\n\n};\n\n/**\n * Get the defined colors for the text color.\n *\n * @param {TinyMCE.Editor} editor\n * @returns {array}\n */\nexport const getForecolorMap = (editor) => editor.options.get(forecolorMap);\n/**\n * Get the defined colors for the background color.\n *\n * @param {TinyMCE.Editor} editor\n * @returns {array}\n */\nexport const getBackcolorMap = (editor) => editor.options.get(backcolorMap);\n/**\n * Get whether the color picker for the text color is enabled.\n *\n * @param {TinyMCE.Editor} editor\n * @returns {boolean}\n */\nexport const isForecolorPickerOn = (editor) => editor.options.get(forecolorPicker);\n/**\n * Get whether the color picker for the background color is enabled.\n *\n * @param {TinyMCE.Editor} editor\n * @returns {boolean}\n */\nexport const isBackcolorPickerOn = (editor) => editor.options.get(backcolorPicker);\n"],"names":["forecolorMap","pluginName","backcolorMap","forecolorPicker","backcolorPicker","editor","options","register","processor","value","processedColors","isString","valid","setTimeout","on","node","selection","getNode","selectedTextColor","window","getComputedStyle","color","selectedBgColor","backgroundColor","filteredColors","dispatch","name","get"],"mappings":";;;;;;;;;MA4BMA,cAAe,gCAAoBC,mBAAY,cAC/CC,cAAe,gCAAoBD,mBAAY,oBAC/CE,iBAAkB,gCAAoBF,mBAAY,mBAClDG,iBAAkB,gCAAoBH,mBAAY,2CAW/BI,SACvBA,OAAOC,QAAQC,SAASP,aAAc,CACpCQ,UAAWC,YAuBHC,iBAAkB,uBAAUD,MAAOE,qBAAY,uBAAUF,OAASA,YAC/D,CACHA,OAAO,+CAAwBC,iBAC/BE,OAAO,YAGJ,KAGbP,OAAOC,QAAQC,SAASL,aAAc,CACpCM,UAAWC,YAuBLC,iBAAkB,uBAAUD,MAAOE,qBAAY,uBAAUF,OAASA,YAC7D,CACHA,OAAO,+CAAwBC,iBAC/BE,OAAO,YAGJ,KAGbC,YAAW,8CACcR,UACtB,KAKHA,OAAOS,GAAG,UAAU,eACdC,KAAOV,OAAOW,UAAUC,UAExBC,mBAAoB,gCAASC,OAAOC,iBAAiBL,MAAMM,OAC3DC,iBAAkB,gCAASH,OAAOC,iBAAiBL,MAAMQ,oBAEzDL,kBAAmB,KACfM,gBAAiB,qDAA8BN,mBACnDb,OAAOC,QAAQC,SAASL,aAAc,CACpCM,UAAW,KACA,CACHC,MAAOe,eACPZ,OAAO,YAGJ,KAGbP,OAAOoB,SAAS,kBAAmB,CAAEC,KAAM,YAAaL,MAAOC,qBAG/DA,gBAAiB,KACbE,gBAAiB,+CAAwBF,iBAC7CjB,OAAOC,QAAQC,SAASP,aAAc,CACpCQ,UAAW,KACA,CACHC,MAAOe,eACPZ,OAAO,YAGJ,KAGbP,OAAOoB,SAAS,kBAAmB,CAAEC,KAAM,YAAaL,MAAOH,wBAKrEb,OAAOC,QAAQC,SAASJ,gBAAiB,CACvCK,UAAW,mBACA,IAGbH,OAAOC,QAAQC,SAASH,gBAAiB,CACvCI,UAAW,mBACA,8BAWiBH,QAAWA,OAAOC,QAAQqB,IAAI3B,uCAO9BK,QAAWA,OAAOC,QAAQqB,IAAIzB,2CAO1BG,QAAWA,OAAOC,QAAQqB,IAAIxB,8CAO9BE,QAAWA,OAAOC,QAAQqB,IAAIvB"}